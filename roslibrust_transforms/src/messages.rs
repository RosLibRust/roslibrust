//! Message type definitions for tf2_msgs.
//!
//! This module contains pre-generated message types for tf2_msgs/TFMessage.
//! The code is generated by running: `cargo test -p roslibrust_transforms message_gen`
//!
//! Both ROS1 and ROS2 message formats are provided:
//! - `ros1` - ROS1 message format (Header has `seq` field, uses `secs`/`nsecs`)
//! - `ros2` - ROS2 message format (Header has no `seq` field, uses `sec`/`nanosec`)

/// ROS1 message types for tf2 functionality.
/// Header uses `seq` field and `stamp` has `secs`/`nsecs` fields.
pub mod ros1 {
    #[allow(unused_imports)]
    pub mod builtin_interfaces {
        use super::geometry_msgs;
        use super::service_msgs;
        use super::std_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Duration {
            pub r#sec: i32,
            pub r#nanosec: u32,
        }
        impl ::roslibrust::RosMessageType for Duration {
            const ROS_TYPE_NAME: &'static str = "builtin_interfaces/Duration";
            const MD5SUM: &'static str = "8255142433c342f21ece78aae48f7907";
            const DEFINITION: &'static str = r####"# Duration defines a period between two time points.
# Messages of this datatype are of ROS Time following this design:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The duration -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The duration 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xe8, 0xd0, 0x09, 0xf6, 0x59, 0x81, 0x6f, 0x75, 0x8b, 0x75, 0x33, 0x4e, 0xe1, 0xa9,
                0xca, 0x5b, 0x5c, 0x0b, 0x85, 0x98, 0x43, 0x26, 0x1f, 0x14, 0xc7, 0xf9, 0x37, 0x34,
                0x95, 0x99, 0xd9, 0x3b,
            ];
            const ROS2_TYPE_NAME: &'static str = "builtin_interfaces::msg::dds_::Duration_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Time {
            pub r#sec: i32,
            pub r#nanosec: u32,
        }
        impl ::roslibrust::RosMessageType for Time {
            const ROS_TYPE_NAME: &'static str = "builtin_interfaces/Time";
            const MD5SUM: &'static str = "8255142433c342f21ece78aae48f7907";
            const DEFINITION: &'static str = r####"# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xb1, 0x06, 0x23, 0x5e, 0x25, 0xa4, 0xc5, 0xed, 0x35, 0x09, 0x8a, 0xa0, 0xa6, 0x1a,
                0x3e, 0xe9, 0xc9, 0xb1, 0x8d, 0x19, 0x7f, 0x39, 0x8b, 0x0e, 0x42, 0x06, 0xce, 0xa9,
                0xac, 0xf9, 0xc1, 0x97,
            ];
            const ROS2_TYPE_NAME: &'static str = "builtin_interfaces::msg::dds_::Time_";
        }
    }
    #[allow(unused_imports)]
    pub mod geometry_msgs {
        use super::builtin_interfaces;
        use super::service_msgs;
        use super::std_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Accel {
            pub r#linear: self::Vector3,
            pub r#angular: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Accel {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Accel";
            const MD5SUM: &'static str = "9f195f881246fdfa2798d1d3eebca84a";
            const DEFINITION: &'static str = r####"# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xdc, 0x44, 0x82, 0x43, 0xde, 0xd9, 0xb1, 0xfc, 0xbc, 0xca, 0x24, 0xab, 0xa0, 0xc2,
                0x2f, 0x01, 0x3d, 0xae, 0x06, 0xc3, 0x54, 0xba, 0x2d, 0x84, 0x95, 0x71, 0xc0, 0xa2,
                0xa3, 0xf5, 0x7c, 0xa0,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Accel_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct AccelStamped {
            pub r#header: std_msgs::Header,
            pub r#accel: self::Accel,
        }
        impl ::roslibrust::RosMessageType for AccelStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/AccelStamped";
            const MD5SUM: &'static str = "d8a98a5d81351b6eb0578c78557e7659";
            const DEFINITION: &'static str = r####"# An accel with reference coordinate frame and timestamp
Header header
Accel accel
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x47, 0xf7, 0x47, 0xd2, 0x60, 0x91, 0xb8, 0x05, 0x7b, 0xd8, 0xe4, 0xc4, 0x9d, 0x9d,
                0x5c, 0xea, 0xcf, 0x6a, 0xe3, 0x92, 0xc1, 0xcc, 0xea, 0x53, 0x22, 0x3f, 0x34, 0x6f,
                0x9c, 0x59, 0x53, 0x2b,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::AccelStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct AccelWithCovariance {
            pub r#accel: self::Accel,
            #[default(_code = "[Default::default(); 36]")]
            #[serde(with = "::roslibrust::codegen::BigArray")]
            pub r#covariance: [f64; 36],
        }
        impl ::roslibrust::RosMessageType for AccelWithCovariance {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/AccelWithCovariance";
            const MD5SUM: &'static str = "ad5a718d699c6be72a02b8d6a139f334";
            const DEFINITION: &'static str = r####"# This expresses acceleration in free space with uncertainty.

Accel accel

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x23, 0x0d, 0x51, 0xbd, 0x53, 0xbc, 0x36, 0xf2, 0x60, 0x57, 0x4e, 0x73, 0xb4, 0x29,
                0x41, 0xce, 0xfe, 0x44, 0x68, 0x47, 0x53, 0x48, 0x0b, 0x6f, 0xc3, 0x30, 0xc0, 0x32,
                0xc5, 0xdb, 0x59, 0x97,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::AccelWithCovariance_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct AccelWithCovarianceStamped {
            pub r#header: std_msgs::Header,
            pub r#accel: self::AccelWithCovariance,
        }
        impl ::roslibrust::RosMessageType for AccelWithCovarianceStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/AccelWithCovarianceStamped";
            const MD5SUM: &'static str = "96adb295225031ec8d57fb4251b0a886";
            const DEFINITION: &'static str = r####"# This represents an estimated accel with reference coordinate frame and timestamp.
Header header
AccelWithCovariance accel
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/AccelWithCovariance
# This expresses acceleration in free space with uncertainty.

Accel accel

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xa3, 0x03, 0x65, 0xcc, 0x01, 0x7d, 0x2c, 0x85, 0xeb, 0x2d, 0x31, 0x0b, 0xb4, 0xf7,
                0x81, 0xce, 0x0d, 0x36, 0x76, 0x22, 0xb0, 0x6e, 0x78, 0x50, 0x8f, 0x00, 0x0f, 0x37,
                0x17, 0x76, 0x14, 0xd6,
            ];
            const ROS2_TYPE_NAME: &'static str =
                "geometry_msgs::msg::dds_::AccelWithCovarianceStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Inertia {
            pub r#m: f64,
            pub r#com: self::Vector3,
            pub r#ixx: f64,
            pub r#ixy: f64,
            pub r#ixz: f64,
            pub r#iyy: f64,
            pub r#iyz: f64,
            pub r#izz: f64,
        }
        impl ::roslibrust::RosMessageType for Inertia {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Inertia";
            const MD5SUM: &'static str = "1d26e4bb6c83ff141c5cf0d883c2b0fe";
            const DEFINITION: &'static str = r####"# Mass [kg]
float64 m

# Center of mass [m]
geometry_msgs/Vector3 com

# Inertia Tensor [kg-m^2]
#     | ixx ixy ixz |
# I = | ixy iyy iyz |
#     | ixz iyz izz |
float64 ixx
float64 ixy
float64 ixz
float64 iyy
float64 iyz
float64 izz
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x2d, 0xdd, 0x5d, 0xab, 0x5c, 0x34, 0x78, 0x25, 0xba, 0x2e, 0x56, 0xc8, 0x95, 0xdd,
                0xcc, 0xfd, 0x0b, 0x8e, 0xfe, 0x53, 0xae, 0x93, 0x1b, 0xf6, 0x7f, 0x90, 0x55, 0x29,
                0x93, 0x0b, 0x4b, 0xd7,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Inertia_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct InertiaStamped {
            pub r#header: std_msgs::Header,
            pub r#inertia: self::Inertia,
        }
        impl ::roslibrust::RosMessageType for InertiaStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/InertiaStamped";
            const MD5SUM: &'static str = "ddee48caeab5a966c5e8d166654a9ac7";
            const DEFINITION: &'static str = r####"Header header
Inertia inertia
================================================================================
MSG: geometry_msgs/Inertia
# Mass [kg]
float64 m

# Center of mass [m]
geometry_msgs/Vector3 com

# Inertia Tensor [kg-m^2]
#     | ixx ixy ixz |
# I = | ixy iyy iyz |
#     | ixz iyz izz |
float64 ixx
float64 ixy
float64 ixz
float64 iyy
float64 iyz
float64 izz
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xbe, 0x07, 0x62, 0x73, 0xdb, 0xb8, 0xe5, 0xac, 0x72, 0x23, 0x2e, 0x91, 0xe5, 0x9b,
                0xc3, 0x95, 0x63, 0xca, 0x1d, 0xb7, 0x7a, 0xd2, 0x0c, 0x2f, 0xa0, 0x3f, 0x1d, 0xf0,
                0x61, 0xdb, 0x7d, 0xe9,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::InertiaStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Point {
            pub r#x: f64,
            pub r#y: f64,
            pub r#z: f64,
        }
        impl ::roslibrust::RosMessageType for Point {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Point";
            const MD5SUM: &'static str = "4a842b65f413084dc2b10fb484ea7f17";
            const DEFINITION: &'static str = r####"# This contains the position of a point in free space
float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x69, 0x63, 0x08, 0x48, 0x42, 0xa9, 0xb0, 0x44, 0x94, 0xd6, 0xb2, 0x94, 0x1d, 0x11,
                0x44, 0x47, 0x08, 0xd8, 0x92, 0xda, 0x2f, 0x4b, 0x09, 0x84, 0x3b, 0x9c, 0x43, 0xf4,
                0x2a, 0x7f, 0x68, 0x81,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Point_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Point32 {
            pub r#x: f32,
            pub r#y: f32,
            pub r#z: f32,
        }
        impl ::roslibrust::RosMessageType for Point32 {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Point32";
            const MD5SUM: &'static str = "cc153912f1453b708d221682bc23d9ac";
            const DEFINITION: &'static str = r####"# This contains the position of a point in free space(with 32 bits of precision).
# It is recommeded to use Point wherever possible instead of Point32.  
# 
# This recommendation is to promote interoperability.  
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.  

float32 x
float32 y
float32 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x2f, 0xc4, 0xdb, 0x7c, 0xae, 0x16, 0xa4, 0x58, 0x2c, 0x79, 0xa5, 0x6b, 0x66, 0x17,
                0x3a, 0x8d, 0x48, 0xd5, 0x2c, 0x7d, 0xc5, 0x20, 0xdd, 0xc5, 0x5a, 0x0d, 0x4b, 0xcf,
                0x2a, 0x4b, 0xfd, 0xbc,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Point32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PointStamped {
            pub r#header: std_msgs::Header,
            pub r#point: self::Point,
        }
        impl ::roslibrust::RosMessageType for PointStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PointStamped";
            const MD5SUM: &'static str = "c63aecb41bfdfd6b7e1fac37c7cbe7bf";
            const DEFINITION: &'static str = r####"# This represents a Point with reference coordinate frame and timestamp
Header header
Point point
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x16, 0x48, 0x46, 0x59, 0xa6, 0x38, 0x7c, 0xf8, 0xf1, 0xda, 0x65, 0x26, 0xb9, 0x4b,
                0x8d, 0xa0, 0x6a, 0xc4, 0x8d, 0x0c, 0x03, 0xc9, 0x5e, 0x5b, 0xf7, 0xec, 0x4c, 0x08,
                0xfe, 0xbb, 0x77, 0x29,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PointStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Polygon {
            pub r#points: ::std::vec::Vec<self::Point32>,
        }
        impl ::roslibrust::RosMessageType for Polygon {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Polygon";
            const MD5SUM: &'static str = "cd60a26494a087f577976f0329fa120e";
            const DEFINITION: &'static str = r####"#A specification of a polygon where the first and last points are assumed to be connected
Point32[] points
================================================================================
MSG: geometry_msgs/Point32
# This contains the position of a point in free space(with 32 bits of precision).
# It is recommeded to use Point wherever possible instead of Point32.  
# 
# This recommendation is to promote interoperability.  
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.  

float32 x
float32 y
float32 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x37, 0x82, 0xf9, 0xf0, 0xbf, 0x04, 0x49, 0x64, 0xd6, 0x92, 0xd6, 0xc0, 0x17, 0xd7,
                0x05, 0xe3, 0x76, 0x11, 0xaf, 0xb1, 0xf0, 0xbf, 0x6a, 0x9d, 0xee, 0x24, 0x8a, 0x7d,
                0xda, 0x0f, 0x78, 0x4a,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Polygon_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PolygonStamped {
            pub r#header: std_msgs::Header,
            pub r#polygon: self::Polygon,
        }
        impl ::roslibrust::RosMessageType for PolygonStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PolygonStamped";
            const MD5SUM: &'static str = "c6be8f7dc3bee7fe9e8d296070f53340";
            const DEFINITION: &'static str = r####"# This represents a Polygon with reference coordinate frame and timestamp
Header header
Polygon polygon
================================================================================
MSG: geometry_msgs/Point32
# This contains the position of a point in free space(with 32 bits of precision).
# It is recommeded to use Point wherever possible instead of Point32.  
# 
# This recommendation is to promote interoperability.  
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.  

float32 x
float32 y
float32 z
================================================================================
MSG: geometry_msgs/Polygon
#A specification of a polygon where the first and last points are assumed to be connected
Point32[] points
================================================================================
MSG: geometry_msgs/Point32
# This contains the position of a point in free space(with 32 bits of precision).
# It is recommeded to use Point wherever possible instead of Point32.  
# 
# This recommendation is to promote interoperability.  
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.  

float32 x
float32 y
float32 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xff, 0xfe, 0xb2, 0xb4, 0xa8, 0xd7, 0x52, 0xeb, 0x71, 0xf4, 0x2f, 0x5e, 0xe5, 0xbf,
                0x2e, 0x0a, 0x78, 0x7d, 0x18, 0xd1, 0xcc, 0x94, 0x03, 0xea, 0x8d, 0x87, 0x8d, 0x1e,
                0x8f, 0x88, 0x07, 0xaf,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PolygonStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Pose {
            pub r#position: self::Point,
            pub r#orientation: self::Quaternion,
        }
        impl ::roslibrust::RosMessageType for Pose {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Pose";
            const MD5SUM: &'static str = "e45d45a5a1ce597b249e23fb30fc871f";
            const DEFINITION: &'static str = r####"# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xd5, 0x01, 0x95, 0x4e, 0x94, 0x76, 0xce, 0xa2, 0x99, 0x69, 0x84, 0xe8, 0x12, 0x05,
                0x4b, 0x68, 0x02, 0x6a, 0xe0, 0xbf, 0xae, 0x78, 0x9d, 0x9a, 0x10, 0xb2, 0x3d, 0xaf,
                0x35, 0xcc, 0x90, 0xfa,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Pose_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Pose2D {
            pub r#x: f64,
            pub r#y: f64,
            pub r#theta: f64,
        }
        impl ::roslibrust::RosMessageType for Pose2D {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Pose2D";
            const MD5SUM: &'static str = "938fa65709584ad8e77d238529be13b8";
            const DEFINITION: &'static str = r####"# Deprecated
# Please use the full 3D pose.

# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.

# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.


# This expresses a position and orientation on a 2D manifold.

float64 x
float64 y
float64 theta"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xd6, 0x8e, 0xfa, 0x5b, 0x46, 0xe7, 0x0f, 0x7b, 0x16, 0xca, 0x23, 0x08, 0x54, 0x74,
                0xfd, 0xac, 0x5a, 0x44, 0xb6, 0x38, 0x78, 0x3e, 0xc4, 0x2f, 0x66, 0x1d, 0xa6, 0x4d,
                0xa4, 0x72, 0x4c, 0xcc,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Pose2D_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseArray {
            pub r#header: std_msgs::Header,
            pub r#poses: ::std::vec::Vec<self::Pose>,
        }
        impl ::roslibrust::RosMessageType for PoseArray {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseArray";
            const MD5SUM: &'static str = "916c28c5764443f268b296bb671b9d97";
            const DEFINITION: &'static str = r####"# An array of poses with a header for global reference.

Header header

Pose[] poses
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x3d, 0xfa, 0xa2, 0x97, 0xe8, 0xef, 0x84, 0x2d, 0x04, 0xd9, 0xea, 0x4f, 0x53, 0x78,
                0xa8, 0xe1, 0xd1, 0xff, 0x86, 0x6f, 0x29, 0x8d, 0xe7, 0xec, 0xf4, 0x35, 0x41, 0xf8,
                0x61, 0x5d, 0x50, 0xed,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PoseArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseStamped {
            pub r#header: std_msgs::Header,
            pub r#pose: self::Pose,
        }
        impl ::roslibrust::RosMessageType for PoseStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseStamped";
            const MD5SUM: &'static str = "d3812c3cbc69362b77dc0b19b345f8f5";
            const DEFINITION: &'static str = r####"# A Pose with reference coordinate frame and timestamp
Header header
Pose pose
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x13, 0x7f, 0xcc, 0xf0, 0xc6, 0x2a, 0x8f, 0x26, 0xbf, 0x49, 0x39, 0x74, 0x73, 0x9b,
                0x58, 0x8f, 0xb8, 0x0d, 0x4b, 0x5c, 0x8d, 0x3a, 0xf6, 0xfe, 0xda, 0x4d, 0x36, 0x45,
                0x20, 0xec, 0x22, 0x6e,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PoseStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseWithCovariance {
            pub r#pose: self::Pose,
            #[default(_code = "[Default::default(); 36]")]
            #[serde(with = "::roslibrust::codegen::BigArray")]
            pub r#covariance: [f64; 36],
        }
        impl ::roslibrust::RosMessageType for PoseWithCovariance {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseWithCovariance";
            const MD5SUM: &'static str = "c23e848cf1b7533a8d7c259073a97e6f";
            const DEFINITION: &'static str = r####"# This represents a pose in free space with uncertainty.

Pose pose

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x9a, 0x7c, 0x0f, 0xd2, 0x34, 0xb7, 0xf4, 0x5c, 0x60, 0x98, 0x74, 0x5e, 0xcc, 0xcd,
                0x77, 0x3c, 0xa1, 0x08, 0x56, 0x70, 0xe6, 0x41, 0x07, 0x13, 0x53, 0x97, 0xae, 0xe3,
                0x1c, 0x02, 0xe1, 0xbb,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PoseWithCovariance_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseWithCovarianceStamped {
            pub r#header: std_msgs::Header,
            pub r#pose: self::PoseWithCovariance,
        }
        impl ::roslibrust::RosMessageType for PoseWithCovarianceStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseWithCovarianceStamped";
            const MD5SUM: &'static str = "953b798c0f514ff060a53a3498ce6246";
            const DEFINITION: &'static str = r####"# This expresses an estimated pose with a reference coordinate frame and timestamp

Header header
PoseWithCovariance pose
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/PoseWithCovariance
# This represents a pose in free space with uncertainty.

Pose pose

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation. 
Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xba, 0x09, 0xde, 0x0d, 0xa1, 0x18, 0xc9, 0xd7, 0x17, 0x53, 0x10, 0xf7, 0x06, 0xfd,
                0x1b, 0x93, 0x10, 0x5e, 0xe7, 0xf7, 0x12, 0x88, 0xc7, 0x1c, 0x23, 0xa0, 0xd1, 0xe9,
                0xe7, 0xe4, 0x48, 0x1a,
            ];
            const ROS2_TYPE_NAME: &'static str =
                "geometry_msgs::msg::dds_::PoseWithCovarianceStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Quaternion {
            pub r#x: f64,
            pub r#y: f64,
            pub r#z: f64,
            pub r#w: f64,
        }
        impl ::roslibrust::RosMessageType for Quaternion {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Quaternion";
            const MD5SUM: &'static str = "a779879fadf0160734f906b8c19c7004";
            const DEFINITION: &'static str = r####"# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x8a, 0x76, 0x5f, 0x66, 0x77, 0x8c, 0x8f, 0xf7, 0xc8, 0xab, 0x94, 0xaf, 0xcc, 0x59,
                0x0a, 0x2e, 0xd5, 0x32, 0x5a, 0x1d, 0x9a, 0x07, 0x6f, 0xff, 0xf3, 0x8f, 0xbc, 0xe3,
                0x6f, 0x45, 0x86, 0x84,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Quaternion_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct QuaternionStamped {
            pub r#header: std_msgs::Header,
            pub r#quaternion: self::Quaternion,
        }
        impl ::roslibrust::RosMessageType for QuaternionStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/QuaternionStamped";
            const MD5SUM: &'static str = "e57f1e547e0e1fd13504588ffc8334e2";
            const DEFINITION: &'static str = r####"# This represents an orientation with reference coordinate frame and timestamp.

Header header
Quaternion quaternion
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x65, 0x47, 0x55, 0x14, 0xfe, 0x6b, 0xf5, 0x8e, 0x6b, 0x0e, 0xcb, 0x47, 0xde, 0xc0,
                0x6e, 0xef, 0xd4, 0x06, 0x79, 0xf6, 0x02, 0xa8, 0xc4, 0xcc, 0x6f, 0x1e, 0x49, 0xa0,
                0xff, 0x45, 0xc8, 0x5d,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::QuaternionStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Transform {
            pub r#translation: self::Vector3,
            pub r#rotation: self::Quaternion,
        }
        impl ::roslibrust::RosMessageType for Transform {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Transform";
            const MD5SUM: &'static str = "ac9eff44abf714214112b05d54a3cf9b";
            const DEFINITION: &'static str = r####"# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xbe, 0xb8, 0x3f, 0xbe, 0x69, 0x86, 0x36, 0x35, 0x14, 0x61, 0xf6, 0xf3, 0x5d, 0x1a,
                0xbb, 0x20, 0x01, 0x0c, 0x43, 0xd5, 0x53, 0x74, 0xd8, 0x1b, 0xd0, 0x41, 0xf1, 0xba,
                0x25, 0x81, 0xfd, 0xdc,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Transform_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TransformStamped {
            pub r#header: std_msgs::Header,
            pub r#child_frame_id: ::std::string::String,
            pub r#transform: self::Transform,
        }
        impl ::roslibrust::RosMessageType for TransformStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TransformStamped";
            const MD5SUM: &'static str = "b5764a33bfeb3588febc2682852579b0";
            const DEFINITION: &'static str = r####"# This expresses a transform from coordinate frame header.frame_id
# to the coordinate frame child_frame_id
#
# This message is mostly used by the 
# <a href="http://wiki.ros.org/tf">tf</a> package. 
# See its documentation for more information.

Header header
string child_frame_id # the frame id of the child frame
Transform transform
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Transform
# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x
float64 y
float64 z
float64 w
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x76, 0xc2, 0xd4, 0xb2, 0x4e, 0x42, 0x44, 0xae, 0x82, 0x0d, 0x8c, 0x98, 0x20, 0x90,
                0x50, 0xcf, 0x29, 0x3b, 0xa0, 0x43, 0x15, 0xaa, 0xde, 0xf5, 0x59, 0xb3, 0xe5, 0xd4,
                0xb9, 0xb8, 0x9d, 0x7c,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::TransformStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Twist {
            pub r#linear: self::Vector3,
            pub r#angular: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Twist {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Twist";
            const MD5SUM: &'static str = "9f195f881246fdfa2798d1d3eebca84a";
            const DEFINITION: &'static str = r####"# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x9c, 0x45, 0xbf, 0x16, 0xfe, 0x09, 0x83, 0xd8, 0x0e, 0x3c, 0xfe, 0x75, 0x0d, 0x68,
                0x35, 0x84, 0x3d, 0x26, 0x5a, 0x9a, 0x6c, 0x46, 0xbd, 0x2e, 0x60, 0x9f, 0xcd, 0xdd,
                0xe6, 0xfb, 0x8d, 0x2a,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Twist_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TwistStamped {
            pub r#header: std_msgs::Header,
            pub r#twist: self::Twist,
        }
        impl ::roslibrust::RosMessageType for TwistStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TwistStamped";
            const MD5SUM: &'static str = "98d34b0043a2093cf9d9345ab6eef12e";
            const DEFINITION: &'static str = r####"# A twist with reference coordinate frame and timestamp
Header header
Twist twist
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x6a, 0xdd, 0x90, 0x5e, 0x39, 0x19, 0x47, 0x17, 0x56, 0xa5, 0xd5, 0x69, 0x0a, 0x0a,
                0x3b, 0x16, 0xe4, 0x69, 0x5c, 0x8c, 0xa4, 0xb7, 0x6b, 0xf7, 0x3d, 0xe7, 0x8a, 0x7c,
                0xa1, 0xd9, 0x73, 0xf4,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::TwistStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TwistWithCovariance {
            pub r#twist: self::Twist,
            #[default(_code = "[Default::default(); 36]")]
            #[serde(with = "::roslibrust::codegen::BigArray")]
            pub r#covariance: [f64; 36],
        }
        impl ::roslibrust::RosMessageType for TwistWithCovariance {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TwistWithCovariance";
            const MD5SUM: &'static str = "1fe8a28e6890a4cc3ae4c3ca5c7d82e6";
            const DEFINITION: &'static str = r####"# This expresses velocity in free space with uncertainty.

Twist twist

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x49, 0xf5, 0x74, 0xf0, 0x33, 0xf0, 0x95, 0xd8, 0xb6, 0xcd, 0x1b, 0xea, 0xca, 0x5c,
                0xa7, 0x92, 0x5e, 0x29, 0x6e, 0x84, 0xaf, 0x17, 0x16, 0xd1, 0x6c, 0x89, 0xd3, 0x8b,
                0x05, 0x9c, 0x8c, 0x18,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::TwistWithCovariance_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TwistWithCovarianceStamped {
            pub r#header: std_msgs::Header,
            pub r#twist: self::TwistWithCovariance,
        }
        impl ::roslibrust::RosMessageType for TwistWithCovarianceStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TwistWithCovarianceStamped";
            const MD5SUM: &'static str = "8927a1a12fb2607ceea095b2dc440a96";
            const DEFINITION: &'static str = r####"# This represents an estimated twist with reference coordinate frame and timestamp.
Header header
TwistWithCovariance twist
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/TwistWithCovariance
# This expresses velocity in free space with uncertainty.

Twist twist

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x5d, 0x9c, 0xa5, 0x12, 0xb1, 0xd6, 0x4f, 0x68, 0x82, 0xc0, 0xe1, 0xed, 0x3f, 0x3e,
                0x58, 0x85, 0x13, 0x56, 0x94, 0x27, 0xa0, 0x9f, 0x0d, 0x54, 0x95, 0xdb, 0xf1, 0xb0,
                0xb0, 0x44, 0x3f, 0x8a,
            ];
            const ROS2_TYPE_NAME: &'static str =
                "geometry_msgs::msg::dds_::TwistWithCovarianceStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Vector3 {
            pub r#x: f64,
            pub r#y: f64,
            pub r#z: f64,
        }
        impl ::roslibrust::RosMessageType for Vector3 {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Vector3";
            const MD5SUM: &'static str = "4a842b65f413084dc2b10fb484ea7f17";
            const DEFINITION: &'static str = r####"# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xcc, 0x12, 0xfe, 0x83, 0xe4, 0xc0, 0x27, 0x19, 0xf1, 0xce, 0x80, 0x70, 0xbf, 0xd1,
                0x4a, 0xec, 0xd4, 0x0f, 0x75, 0xa9, 0x66, 0x96, 0xa6, 0x7a, 0x2a, 0x1f, 0x37, 0xf7,
                0xdb, 0xb0, 0x76, 0x5d,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Vector3_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Vector3Stamped {
            pub r#header: std_msgs::Header,
            pub r#vector: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Vector3Stamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Vector3Stamped";
            const MD5SUM: &'static str = "7b324c7325e683bf02a9b14b01090ec7";
            const DEFINITION: &'static str = r####"# This represents a Vector3 with reference coordinate frame and timestamp
Header header
Vector3 vector
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xcc, 0x30, 0xa6, 0x24, 0x13, 0xb4, 0x62, 0x5e, 0x67, 0xec, 0xe5, 0x7a, 0x3f, 0x06,
                0x5e, 0x1b, 0x5d, 0x51, 0xd8, 0xcf, 0x6a, 0xa4, 0x08, 0x70, 0x61, 0x99, 0xc4, 0xe5,
                0xe8, 0x26, 0x11, 0xfa,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Vector3Stamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Wrench {
            pub r#force: self::Vector3,
            pub r#torque: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Wrench {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Wrench";
            const MD5SUM: &'static str = "4f539cf138b23283b520fd271b567936";
            const DEFINITION: &'static str = r####"# This represents force in free space, separated into
# its linear and angular parts.
Vector3  force
Vector3  torque
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x01, 0x8e, 0x85, 0x19, 0xd5, 0x7c, 0x16, 0xad, 0xbe, 0x97, 0xc9, 0xfe, 0x14, 0x60,
                0xef, 0x21, 0xfe, 0xc7, 0xe3, 0x1b, 0xc5, 0x41, 0xde, 0x3d, 0x65, 0x3a, 0x35, 0x89,
                0x56, 0x77, 0xce, 0x52,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Wrench_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct WrenchStamped {
            pub r#header: std_msgs::Header,
            pub r#wrench: self::Wrench,
        }
        impl ::roslibrust::RosMessageType for WrenchStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/WrenchStamped";
            const MD5SUM: &'static str = "d78d3cb249ce23087ade7e7d0c40cfa7";
            const DEFINITION: &'static str = r####"# A wrench with reference coordinate frame and timestamp
Header header
Wrench wrench
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Wrench
# This represents force in free space, separated into
# its linear and angular parts.
Vector3  force
Vector3  torque
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space. 
# It is only meant to represent a direction. Therefore, it does not
# make sense to apply a translation to it (e.g., when applying a 
# generic rigid transformation to a Vector3, tf2 will only apply the
# rotation). If you want your data to be translatable too, use the
# geometry_msgs/Point message instead.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x91, 0x34, 0xc4, 0x7a, 0x80, 0xba, 0x54, 0xcd, 0x3d, 0x73, 0x1c, 0xde, 0x2b, 0x39,
                0x5c, 0x0b, 0xf2, 0x71, 0x09, 0x07, 0x68, 0x47, 0x46, 0xb3, 0x97, 0xc2, 0x56, 0xea,
                0x58, 0x63, 0xde, 0x17,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::WrenchStamped_";
        }
    }
    #[allow(unused_imports)]
    pub mod service_msgs {
        use super::builtin_interfaces;
        use super::geometry_msgs;
        use super::std_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct ServiceEventInfo {
            pub r#event_type: u8,
            pub r#stamp: builtin_interfaces::Time,
            pub r#client_gid: [u8; 16],
            pub r#sequence_number: i64,
        }
        impl ::roslibrust::RosMessageType for ServiceEventInfo {
            const ROS_TYPE_NAME: &'static str = "service_msgs/ServiceEventInfo";
            const MD5SUM: &'static str = "42561fc0d0d3665a03d59fbb1296daf9";
            const DEFINITION: &'static str = r####"uint8 REQUEST_SENT = 0
uint8 REQUEST_RECEIVED = 1
uint8 RESPONSE_SENT = 2
uint8 RESPONSE_RECEIVED = 3

# The type of event this message represents
uint8 event_type

# Timestamp for when the event occurred (sent or received time)
builtin_interfaces/Time stamp

# Unique identifier for the client that sent the service request
# Note, this is only unique for the current session.
# The size here has to match the size of rmw_dds_common/msg/Gid,
# but unfortunately we cannot use that message directly due to a
# circular dependency.
char[16] client_gid

# Sequence number for the request
# Combined with the client ID, this creates a unique ID for the service transaction
int64 sequence_number
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x41, 0xbc, 0xbb, 0xe0, 0x7a, 0x75, 0xc9, 0xb5, 0x2b, 0xc9, 0x6b, 0xfd, 0x5c, 0x24,
                0xd7, 0xf0, 0xfc, 0x0a, 0x08, 0xc0, 0xcb, 0x79, 0x21, 0xb3, 0x37, 0x3c, 0x57, 0x32,
                0x34, 0x5a, 0x6f, 0x45,
            ];
            const ROS2_TYPE_NAME: &'static str = "service_msgs::msg::dds_::ServiceEventInfo_";
        }
        #[allow(unused)]
        impl ServiceEventInfo {
            pub const r#REQUEST_SENT: u8 = 0u8;
            pub const r#REQUEST_RECEIVED: u8 = 1u8;
            pub const r#RESPONSE_SENT: u8 = 2u8;
            pub const r#RESPONSE_RECEIVED: u8 = 3u8;
        }
    }
    #[allow(unused_imports)]
    pub mod std_msgs {
        use super::builtin_interfaces;
        use super::geometry_msgs;
        use super::service_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Bool {
            pub r#data: bool,
        }
        impl ::roslibrust::RosMessageType for Bool {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Bool";
            const MD5SUM: &'static str = "8b94c1b53db61fb6aed406028ad6332a";
            const DEFINITION: &'static str = r####"bool data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xfe, 0xb9, 0x1e, 0x99, 0x5f, 0xf9, 0xeb, 0xd0, 0x9c, 0x0c, 0xb3, 0xd2, 0xae, 0xd1,
                0x8b, 0x11, 0x07, 0x75, 0x85, 0x83, 0x9f, 0xb5, 0xdb, 0x80, 0x19, 0x3b, 0x62, 0xd7,
                0x45, 0x28, 0xf6, 0xc9,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Bool_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Byte {
            pub r#data: u8,
        }
        impl ::roslibrust::RosMessageType for Byte {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Byte";
            const MD5SUM: &'static str = "ad736a2e8818154c487bb80fe42ce43b";
            const DEFINITION: &'static str = r####"byte data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xe2, 0x8c, 0xa2, 0xc6, 0x2f, 0x3f, 0xb1, 0x0c, 0x20, 0x78, 0x90, 0x75, 0x5a, 0xa7,
                0xa5, 0xa7, 0x70, 0xcc, 0xde, 0x56, 0x46, 0xfd, 0x66, 0xb4, 0x52, 0xf4, 0x85, 0xc4,
                0x80, 0x92, 0xf3, 0x27,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Byte_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct ByteMultiArray {
            pub r#layout: self::MultiArrayLayout,
            #[serde(with = "::roslibrust::codegen::serde_rosmsg_bytes")]
            pub r#data: ::std::vec::Vec<u8>,
        }
        impl ::roslibrust::RosMessageType for ByteMultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/ByteMultiArray";
            const MD5SUM: &'static str = "70ea476cbcfd65ac2f68f3cda1e891fe";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
byte[]            data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x69, 0x2e, 0xff, 0x26, 0xdd, 0x8c, 0xa7, 0x62, 0x3e, 0x4e, 0x90, 0xa0, 0x82, 0xf7,
                0xd8, 0x3f, 0x1c, 0xf5, 0xde, 0xb0, 0xb7, 0xba, 0x74, 0x8a, 0x2d, 0x4d, 0x5f, 0xbc,
                0xa7, 0x91, 0xdb, 0x7d,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::ByteMultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Char {
            pub r#data: u8,
        }
        impl ::roslibrust::RosMessageType for Char {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Char";
            const MD5SUM: &'static str = "1bf77f25acecdedba0e224b162199717";
            const DEFINITION: &'static str = r####"char data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x3a, 0xd2, 0xd0, 0x4d, 0xd2, 0x9b, 0xa1, 0x9d, 0x04, 0xb1, 0x66, 0x59, 0xaf, 0xa3,
                0xcc, 0xae, 0xdd, 0x69, 0x19, 0x14, 0xb0, 0x2a, 0x64, 0xe8, 0x2e, 0x25, 0x2f, 0x2f,
                0xa6, 0xa5, 0x86, 0xa9,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Char_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct ColorRGBA {
            pub r#r: f32,
            pub r#g: f32,
            pub r#b: f32,
            pub r#a: f32,
        }
        impl ::roslibrust::RosMessageType for ColorRGBA {
            const ROS_TYPE_NAME: &'static str = "std_msgs/ColorRGBA";
            const MD5SUM: &'static str = "a29a96539573343b1310c73607334b00";
            const DEFINITION: &'static str = r####"float32 r
float32 g
float32 b
float32 a"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x77, 0xa7, 0xa5, 0xb9, 0xae, 0x47, 0x73, 0x06, 0x09, 0x76, 0x65, 0x10, 0x6e, 0x04,
                0x13, 0xba, 0x74, 0x44, 0x02, 0x45, 0xb1, 0xf3, 0xd0, 0xc6, 0xd6, 0x40, 0x5f, 0xe5,
                0xc7, 0x81, 0x3f, 0xe8,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::ColorRGBA_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Duration {
            pub r#data: ::roslibrust::codegen::integral_types::Duration,
        }
        impl ::roslibrust::RosMessageType for Duration {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Duration";
            const MD5SUM: &'static str = "3e286caf4241d664e55f3ad380e2ae46";
            const DEFINITION: &'static str = r####"duration data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x64, 0x12, 0xd7, 0xf2, 0x6b, 0x75, 0xc8, 0xbd, 0xcd, 0x9b, 0x9f, 0xea, 0xe3, 0xa8,
                0xa1, 0x15, 0x7f, 0x39, 0x50, 0x68, 0xa4, 0x0e, 0x97, 0xc0, 0x43, 0x7f, 0x1a, 0x34,
                0xfe, 0x1a, 0x37, 0x94,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Duration_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Empty {}
        impl ::roslibrust::RosMessageType for Empty {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Empty";
            const MD5SUM: &'static str = "d41d8cd98f00b204e9800998ecf8427e";
            const DEFINITION: &'static str = r####""####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x20, 0xb6, 0x25, 0x25, 0x6f, 0x32, 0xd5, 0xdb, 0xc0, 0xd0, 0x4f, 0xee, 0x44, 0xf4,
                0x3c, 0x41, 0xe5, 0x1c, 0x70, 0xd3, 0x50, 0x2f, 0x84, 0xb4, 0xa0, 0x8e, 0x7a, 0x9c,
                0x26, 0xa9, 0x63, 0x12,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Empty_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float32 {
            pub r#data: f32,
        }
        impl ::roslibrust::RosMessageType for Float32 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float32";
            const MD5SUM: &'static str = "73fcbf46b49191e672908e50842a83d4";
            const DEFINITION: &'static str = r####"float32 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x71, 0x70, 0xd3, 0xd8, 0xf8, 0x41, 0xf7, 0xbe, 0x31, 0x72, 0xce, 0x5f, 0x4f, 0x59,
                0xf3, 0xa4, 0xd7, 0xf6, 0x3b, 0x04, 0x47, 0xe8, 0xb3, 0x33, 0x27, 0x60, 0x1a, 0xd6,
                0x4d, 0x83, 0xd6, 0xe2,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float32MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<f32>,
        }
        impl ::roslibrust::RosMessageType for Float32MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float32MultiArray";
            const MD5SUM: &'static str = "6a40e0ffa6a17a503ac3f8616991b1f6";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float32[]         data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x05, 0x99, 0xf6, 0xf8, 0x5b, 0x4b, 0xfc, 0xa3, 0x79, 0x87, 0x3a, 0x0b, 0x43, 0x75,
                0xa0, 0xac, 0xa0, 0x22, 0x15, 0x6b, 0xd2, 0xd7, 0x02, 0x12, 0x75, 0xd1, 0x16, 0xed,
                0x1f, 0xa8, 0xbf, 0xe0,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float32MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float64 {
            pub r#data: f64,
        }
        impl ::roslibrust::RosMessageType for Float64 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float64";
            const MD5SUM: &'static str = "fdb28210bfa9d7c91146260178d9a584";
            const DEFINITION: &'static str = r####"float64 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x70, 0x5b, 0xa9, 0xc3, 0xd1, 0xa0, 0x9d, 0xf4, 0x37, 0x37, 0xeb, 0x67, 0x09, 0x55,
                0x34, 0xde, 0x36, 0xfd, 0x42, 0x6c, 0x05, 0x87, 0x77, 0x9b, 0xda, 0x2b, 0xc5, 0x1f,
                0xe7, 0x90, 0x18, 0x2a,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float64_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float64MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<f64>,
        }
        impl ::roslibrust::RosMessageType for Float64MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float64MultiArray";
            const MD5SUM: &'static str = "4b7d974086d4060e7db4613a7e6c3ba4";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float64[]         data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x10, 0x25, 0xdd, 0xc6, 0xb9, 0x55, 0x2d, 0x19, 0x1f, 0x89, 0xef, 0x1a, 0x8d, 0x2f,
                0x60, 0xf3, 0xd3, 0x73, 0xe2, 0x8b, 0x28, 0x3d, 0x88, 0x91, 0xdd, 0xcc, 0x97, 0x4e,
                0x8c, 0x55, 0x39, 0x7f,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float64MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Header {
            pub r#seq: u32,
            pub r#stamp: ::roslibrust::codegen::integral_types::Time,
            pub r#frame_id: ::std::string::String,
        }
        impl ::roslibrust::RosMessageType for Header {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Header";
            const MD5SUM: &'static str = "2176decaecbce78abc3b96ef049fabed";
            const DEFINITION: &'static str = r####"# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
string frame_id"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xfc, 0xd1, 0x24, 0x61, 0x88, 0xef, 0xb1, 0x45, 0x97, 0x36, 0x58, 0x89, 0xd5, 0xad,
                0xcd, 0x52, 0xac, 0xb6, 0x89, 0x29, 0x29, 0xa1, 0xd2, 0x77, 0x05, 0xef, 0xcd, 0x34,
                0x3d, 0xc7, 0x96, 0x0f,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Header_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int16 {
            pub r#data: i16,
        }
        impl ::roslibrust::RosMessageType for Int16 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int16";
            const MD5SUM: &'static str = "8524586e34fbd7cb1c08c5f5f1ca0e57";
            const DEFINITION: &'static str = r####"int16 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x1d, 0xcc, 0x34, 0x64, 0xe4, 0x7c, 0x28, 0x8a, 0x55, 0xf9, 0x43, 0xa3, 0x89, 0xd3,
                0x37, 0xcd, 0xb0, 0x68, 0x04, 0xde, 0x3f, 0x5c, 0xd7, 0xa2, 0x66, 0xb0, 0xde, 0x71,
                0x8e, 0xee, 0x17, 0xe5,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int16_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int16MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i16>,
        }
        impl ::roslibrust::RosMessageType for Int16MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int16MultiArray";
            const MD5SUM: &'static str = "d9338d7f523fcb692fae9d0a0e9f067c";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int16[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xb5, 0x88, 0x10, 0xe8, 0xe5, 0xb9, 0x0f, 0xb1, 0x9a, 0x50, 0x62, 0x46, 0x9e, 0xb8,
                0x40, 0x9f, 0x5a, 0xb1, 0x1a, 0x44, 0x6d, 0x60, 0xde, 0x71, 0x57, 0xa1, 0x45, 0x7e,
                0x52, 0xa0, 0x76, 0xce,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int16MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int32 {
            pub r#data: i32,
        }
        impl ::roslibrust::RosMessageType for Int32 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int32";
            const MD5SUM: &'static str = "da5909fbe378aeaf85e547e830cc1bb7";
            const DEFINITION: &'static str = r####"int32 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xb6, 0x57, 0x8d, 0xed, 0x3c, 0x58, 0xc6, 0x26, 0xcf, 0xe8, 0xd1, 0xa6, 0xfb, 0x6e,
                0x04, 0xf7, 0x06, 0xf9, 0x7e, 0x9f, 0x03, 0xd2, 0x72, 0x7c, 0x9f, 0xf4, 0xe7, 0x4b,
                0x1c, 0xef, 0x0d, 0xeb,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int32MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i32>,
        }
        impl ::roslibrust::RosMessageType for Int32MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int32MultiArray";
            const MD5SUM: &'static str = "1d99f79f8b325b44fee908053e9c945b";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int32[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x84, 0xa7, 0x34, 0x63, 0x23, 0x52, 0x5d, 0x1b, 0x4d, 0xfc, 0xa8, 0x99, 0xdf, 0x38,
                0x20, 0xf2, 0x45, 0xe5, 0x40, 0x09, 0xda, 0xc5, 0xa6, 0xb6, 0x92, 0x17, 0xd1, 0x4f,
                0xde, 0xfd, 0x17, 0x01,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int32MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int64 {
            pub r#data: i64,
        }
        impl ::roslibrust::RosMessageType for Int64 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int64";
            const MD5SUM: &'static str = "34add168574510e6e17f5d23ecc077ef";
            const DEFINITION: &'static str = r####"int64 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x8c, 0xd1, 0x04, 0x8c, 0x2f, 0x18, 0x6b, 0x6b, 0xd9, 0xa9, 0x24, 0x72, 0xdc, 0x1c,
                0xe5, 0x17, 0x23, 0xc0, 0x83, 0x3a, 0x22, 0x1e, 0x2b, 0x7a, 0xec, 0xff, 0xf1, 0x11,
                0x77, 0x4f, 0x4b, 0x49,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int64_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int64MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i64>,
        }
        impl ::roslibrust::RosMessageType for Int64MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int64MultiArray";
            const MD5SUM: &'static str = "54865aa6c65be0448113a2afc6a49270";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int64[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xe6, 0x0f, 0x9f, 0xe3, 0x4d, 0x69, 0x7f, 0x09, 0x39, 0xad, 0x49, 0xd3, 0x31, 0x58,
                0x69, 0x3c, 0x12, 0x77, 0xfb, 0xac, 0x0e, 0x2f, 0x04, 0xb7, 0xc2, 0x99, 0x5d, 0xc2,
                0x1c, 0x89, 0xb4, 0x22,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int64MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int8 {
            pub r#data: i8,
        }
        impl ::roslibrust::RosMessageType for Int8 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int8";
            const MD5SUM: &'static str = "27ffa0c9c4b8fb8492252bcad9e5c57b";
            const DEFINITION: &'static str = r####"int8 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x26, 0x52, 0x50, 0x65, 0xa4, 0x03, 0xd9, 0x72, 0xcb, 0x67, 0x2f, 0x07, 0x77, 0xe3,
                0x33, 0xf0, 0xc7, 0x99, 0xad, 0x44, 0x4a, 0xe5, 0xfc, 0xd7, 0x9e, 0x43, 0xd1, 0xe7,
                0x3b, 0xd0, 0xf4, 0x40,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int8_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int8MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i8>,
        }
        impl ::roslibrust::RosMessageType for Int8MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int8MultiArray";
            const MD5SUM: &'static str = "d7c1af35a1b4781bbe79e03dd94b7c13";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int8[]            data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xf2, 0x19, 0x98, 0xd4, 0xb4, 0x92, 0xab, 0xd6, 0x33, 0x30, 0x76, 0x5d, 0x75, 0xd5,
                0x83, 0x12, 0x38, 0xd4, 0x00, 0x74, 0x03, 0x86, 0xf6, 0x51, 0xf1, 0x3a, 0x87, 0x2a,
                0x4d, 0x21, 0x88, 0xdb,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int8MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct MultiArrayDimension {
            pub r#label: ::std::string::String,
            pub r#size: u32,
            pub r#stride: u32,
        }
        impl ::roslibrust::RosMessageType for MultiArrayDimension {
            const ROS_TYPE_NAME: &'static str = "std_msgs/MultiArrayDimension";
            const MD5SUM: &'static str = "4cd0c83a8683deae40ecdac60e53bfa8";
            const DEFINITION: &'static str = r####"string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x5e, 0x77, 0x3a, 0x60, 0xa4, 0xc7, 0xfc, 0x8a, 0x54, 0x98, 0x5f, 0x30, 0x7c, 0x78,
                0x37, 0xaa, 0x29, 0x94, 0x25, 0x2a, 0x12, 0x6c, 0x30, 0x19, 0x57, 0xa2, 0x4e, 0x31,
                0x28, 0x2c, 0x9c, 0xbe,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::MultiArrayDimension_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct MultiArrayLayout {
            pub r#dim: ::std::vec::Vec<self::MultiArrayDimension>,
            pub r#data_offset: u32,
        }
        impl ::roslibrust::RosMessageType for MultiArrayLayout {
            const ROS_TYPE_NAME: &'static str = "std_msgs/MultiArrayLayout";
            const MD5SUM: &'static str = "0fed2a11c13e11c5571b4e2a995a91a3";
            const DEFINITION: &'static str = r####"# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x4c, 0x66, 0xe6, 0xf7, 0x8e, 0x74, 0x0a, 0xc1, 0x03, 0xa9, 0x4c, 0xf6, 0x32, 0x59,
                0xf9, 0x68, 0xe4, 0x8c, 0x61, 0x7e, 0x76, 0x99, 0xe8, 0x29, 0xb6, 0x3c, 0x21, 0xa5,
                0xcb, 0x50, 0xda, 0xc6,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::MultiArrayLayout_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct String {
            pub r#data: ::std::string::String,
        }
        impl ::roslibrust::RosMessageType for String {
            const ROS_TYPE_NAME: &'static str = "std_msgs/String";
            const MD5SUM: &'static str = "992ce8a1687cec8c8bd883ec73ca41d1";
            const DEFINITION: &'static str = r####"string data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xdf, 0x66, 0x8c, 0x74, 0x04, 0x82, 0xbb, 0xd4, 0x8f, 0xb3, 0x9d, 0x76, 0xa7, 0x0d,
                0xfd, 0x4b, 0xd5, 0x9d, 0xb1, 0x28, 0x80, 0x21, 0x74, 0x35, 0x03, 0x25, 0x9e, 0x94,
                0x8f, 0x6b, 0x1a, 0x18,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::String_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Time {
            pub r#data: ::roslibrust::codegen::integral_types::Time,
        }
        impl ::roslibrust::RosMessageType for Time {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Time";
            const MD5SUM: &'static str = "cd7166c74c552c311fbcc2fe5a7bc289";
            const DEFINITION: &'static str = r####"time data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xe5, 0x77, 0xc4, 0x61, 0x30, 0x6c, 0xfd, 0x1c, 0xbf, 0x5b, 0xbf, 0x5c, 0x87, 0x4b,
                0x03, 0x8b, 0x7f, 0x3d, 0xcd, 0x6f, 0x16, 0xa1, 0x9b, 0x7f, 0xe6, 0x69, 0x63, 0xc2,
                0x3d, 0x47, 0x84, 0xa0,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Time_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt16 {
            pub r#data: u16,
        }
        impl ::roslibrust::RosMessageType for UInt16 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt16";
            const MD5SUM: &'static str = "1df79edf208b629fe6b81923a544552d";
            const DEFINITION: &'static str = r####"uint16 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x08, 0xa4, 0x06, 0xe4, 0xb0, 0x22, 0xbc, 0x22, 0xe9, 0x07, 0xf9, 0x85, 0xd6, 0xa9,
                0xe9, 0xdd, 0x1d, 0x4f, 0xbe, 0xca, 0xe5, 0x73, 0x54, 0x9c, 0xf4, 0x93, 0x50, 0x11,
                0x3e, 0x77, 0x57, 0xb1,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt16_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt16MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<u16>,
        }
        impl ::roslibrust::RosMessageType for UInt16MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt16MultiArray";
            const MD5SUM: &'static str = "52f264f1c973c4b73790d384c6cb4484";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint16[]            data        # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x94, 0xfe, 0x73, 0x42, 0x8e, 0xc6, 0x3b, 0xae, 0xcc, 0x77, 0x4f, 0x8f, 0xb8, 0x24,
                0x06, 0x12, 0x3e, 0x92, 0x91, 0xcf, 0x72, 0x8f, 0x1b, 0x7c, 0x91, 0xca, 0xf5, 0x33,
                0x51, 0x29, 0x49, 0x2b,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt16MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt32 {
            pub r#data: u32,
        }
        impl ::roslibrust::RosMessageType for UInt32 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt32";
            const MD5SUM: &'static str = "304a39449588c7f8ce2df6e8001c5fce";
            const DEFINITION: &'static str = r####"uint32 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xa5, 0xc8, 0x74, 0x82, 0x9b, 0x75, 0x2b, 0xc5, 0xfa, 0x19, 0x00, 0x24, 0xb0, 0xad,
                0x76, 0xf5, 0x78, 0xcc, 0x27, 0x82, 0x71, 0xe8, 0x55, 0xc7, 0xd0, 0x2a, 0x81, 0x8b,
                0x35, 0x16, 0xfb, 0x4a,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt32MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<u32>,
        }
        impl ::roslibrust::RosMessageType for UInt32MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt32MultiArray";
            const MD5SUM: &'static str = "4d6a180abc9be191b96a7eda6c8a233d";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint32[]          data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x6c, 0x25, 0x77, 0xc7, 0xad, 0x3c, 0xbd, 0xcc, 0x21, 0x64, 0xa4, 0x1c, 0x12, 0xf1,
                0xd5, 0xad, 0x31, 0x4e, 0xa3, 0x20, 0xf3, 0xfb, 0x1e, 0xe4, 0x7e, 0x78, 0x01, 0x9f,
                0xe1, 0x6b, 0xb5, 0xb0,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt32MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt64 {
            pub r#data: u64,
        }
        impl ::roslibrust::RosMessageType for UInt64 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt64";
            const MD5SUM: &'static str = "1b2a79973e8bf53d7b53acb71299cb57";
            const DEFINITION: &'static str = r####"uint64 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xfb, 0xdc, 0x52, 0x01, 0x8f, 0xc1, 0x37, 0x55, 0xdc, 0xe1, 0x80, 0x24, 0xd1, 0xa6,
                0x71, 0xc8, 0x56, 0xaa, 0x8b, 0x4a, 0xaf, 0x63, 0xad, 0xfb, 0x09, 0x5b, 0x60, 0x8f,
                0x98, 0xe8, 0xc9, 0x43,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt64_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt64MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<u64>,
        }
        impl ::roslibrust::RosMessageType for UInt64MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt64MultiArray";
            const MD5SUM: &'static str = "6088f127afb1d6c72927aa1247e945af";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint64[]          data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xfc, 0x1c, 0x68, 0x5c, 0x2f, 0x76, 0xbd, 0xc6, 0x98, 0x3d, 0xa0, 0x25, 0xcb, 0x25,
                0xd2, 0xdb, 0x5f, 0xb5, 0x15, 0x7b, 0x05, 0x9e, 0x30, 0x0f, 0x6d, 0x95, 0x7d, 0x86,
                0xf9, 0x81, 0xb3, 0x66,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt64MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt8 {
            pub r#data: u8,
        }
        impl ::roslibrust::RosMessageType for UInt8 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt8";
            const MD5SUM: &'static str = "7c8164229e7d2c17eb95e9231617fdee";
            const DEFINITION: &'static str = r####"uint8 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x61, 0x38, 0xbd, 0x83, 0xd8, 0xc3, 0x56, 0x9c, 0xb8, 0x0a, 0x66, 0x7d, 0xb0, 0x3c,
                0xfc, 0x16, 0x29, 0xf5, 0x29, 0xfe, 0xe7, 0x9d, 0x94, 0x4c, 0x39, 0xc3, 0x4e, 0x35,
                0x2e, 0x72, 0xf0, 0x10,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt8_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt8MultiArray {
            pub r#layout: self::MultiArrayLayout,
            #[serde(with = "::roslibrust::codegen::serde_rosmsg_bytes")]
            pub r#data: ::std::vec::Vec<u8>,
        }
        impl ::roslibrust::RosMessageType for UInt8MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt8MultiArray";
            const MD5SUM: &'static str = "82373f1612381bb6ee473b5cd6f5d89c";
            const DEFINITION: &'static str = r####"# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint8[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding elements at front of data

# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
# 
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.
================================================================================
MSG: std_msgs/MultiArrayDimension
string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x56, 0x87, 0xe8, 0x61, 0xb8, 0xd3, 0x07, 0xa5, 0xe4, 0x8b, 0x75, 0x15, 0x46, 0x7a,
                0xe7, 0xa5, 0xfc, 0x2d, 0xaf, 0x80, 0x5b, 0xd0, 0xce, 0x6d, 0x8e, 0x9e, 0x60, 0x4b,
                0xad, 0xe9, 0xf3, 0x85,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt8MultiArray_";
        }
    }

    /// TFMessage is the message type published on /tf and /tf_static topics.
    /// It contains an array of geometry_msgs/TransformStamped messages.
    #[allow(non_snake_case)]
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        ::roslibrust::codegen::SmartDefault,
        Debug,
        Clone,
        PartialEq,
    )]
    pub struct TFMessage {
        pub transforms: Vec<geometry_msgs::TransformStamped>,
    }

    impl ::roslibrust_common::RosMessageType for TFMessage {
        const ROS_TYPE_NAME: &'static str = "tf2_msgs/TFMessage";
        const MD5SUM: &'static str = "94810edda583a504dfda3829e70d7eec";
        const DEFINITION: &'static str = "geometry_msgs/TransformStamped[] transforms";
        const ROS2_HASH: &'static [u8; 32] = &[
            0x84, 0x64, 0x1e, 0xf6, 0x1a, 0x5a, 0xa7, 0xf4, 0x9e, 0x8f, 0xc3, 0xca, 0x2f, 0x3c,
            0xf7, 0x3e, 0x24, 0x3a, 0x50, 0x7c, 0xc6, 0x5a, 0x6b, 0x93, 0xe4, 0x1a, 0xa3, 0x57,
            0x83, 0xd1, 0x94, 0x71,
        ];
        const ROS2_TYPE_NAME: &'static str = "tf2_msgs::msg::dds_::TFMessage_";
    }
}

/// ROS2 message types for tf2 functionality.
/// Header has no `seq` field and `stamp` has `sec`/`nanosec` fields.
pub mod ros2 {
    #[allow(unused_imports)]
    pub mod builtin_interfaces {
        use super::geometry_msgs;
        use super::service_msgs;
        use super::std_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Duration {
            pub r#sec: i32,
            pub r#nanosec: u32,
        }
        impl ::roslibrust::RosMessageType for Duration {
            const ROS_TYPE_NAME: &'static str = "builtin_interfaces/Duration";
            const MD5SUM: &'static str = "8255142433c342f21ece78aae48f7907";
            const DEFINITION: &'static str = r####"# Duration defines a period between two time points.
# Messages of this datatype are of ROS Time following this design:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The duration -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The duration 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xe8, 0xd0, 0x09, 0xf6, 0x59, 0x81, 0x6f, 0x75, 0x8b, 0x75, 0x33, 0x4e, 0xe1, 0xa9,
                0xca, 0x5b, 0x5c, 0x0b, 0x85, 0x98, 0x43, 0x26, 0x1f, 0x14, 0xc7, 0xf9, 0x37, 0x34,
                0x95, 0x99, 0xd9, 0x3b,
            ];
            const ROS2_TYPE_NAME: &'static str = "builtin_interfaces::msg::dds_::Duration_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Time {
            pub r#sec: i32,
            pub r#nanosec: u32,
        }
        impl ::roslibrust::RosMessageType for Time {
            const ROS_TYPE_NAME: &'static str = "builtin_interfaces/Time";
            const MD5SUM: &'static str = "8255142433c342f21ece78aae48f7907";
            const DEFINITION: &'static str = r####"# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xb1, 0x06, 0x23, 0x5e, 0x25, 0xa4, 0xc5, 0xed, 0x35, 0x09, 0x8a, 0xa0, 0xa6, 0x1a,
                0x3e, 0xe9, 0xc9, 0xb1, 0x8d, 0x19, 0x7f, 0x39, 0x8b, 0x0e, 0x42, 0x06, 0xce, 0xa9,
                0xac, 0xf9, 0xc1, 0x97,
            ];
            const ROS2_TYPE_NAME: &'static str = "builtin_interfaces::msg::dds_::Time_";
        }
    }
    #[allow(unused_imports)]
    pub mod geometry_msgs {
        use super::builtin_interfaces;
        use super::service_msgs;
        use super::std_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Accel {
            pub r#linear: self::Vector3,
            pub r#angular: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Accel {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Accel";
            const MD5SUM: &'static str = "9f195f881246fdfa2798d1d3eebca84a";
            const DEFINITION: &'static str = r####"# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xdc, 0x44, 0x82, 0x43, 0xde, 0xd9, 0xb1, 0xfc, 0xbc, 0xca, 0x24, 0xab, 0xa0, 0xc2,
                0x2f, 0x01, 0x3d, 0xae, 0x06, 0xc3, 0x54, 0xba, 0x2d, 0x84, 0x95, 0x71, 0xc0, 0xa2,
                0xa3, 0xf5, 0x7c, 0xa0,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Accel_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct AccelStamped {
            pub r#header: std_msgs::Header,
            pub r#accel: self::Accel,
        }
        impl ::roslibrust::RosMessageType for AccelStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/AccelStamped";
            const MD5SUM: &'static str = "714bbd985d9cfc562b1eb5aaa96c7be0";
            const DEFINITION: &'static str = r####"# An accel with reference coordinate frame and timestamp
std_msgs/Header header
Accel accel
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xef, 0x1d, 0xf9, 0xea, 0xba, 0xe0, 0xa7, 0x08, 0xcc, 0x04, 0x9a, 0x06, 0x1e, 0xbc,
                0xdd, 0xc4, 0xe2, 0xa5, 0xf7, 0x45, 0x73, 0x01, 0x00, 0xba, 0x68, 0x0e, 0x08, 0x6a,
                0x96, 0x98, 0xb1, 0x65,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::AccelStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct AccelWithCovariance {
            pub r#accel: self::Accel,
            #[default(_code = "[Default::default(); 36]")]
            #[serde(with = "::roslibrust::codegen::BigArray")]
            pub r#covariance: [f64; 36],
        }
        impl ::roslibrust::RosMessageType for AccelWithCovariance {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/AccelWithCovariance";
            const MD5SUM: &'static str = "ad5a718d699c6be72a02b8d6a139f334";
            const DEFINITION: &'static str = r####"# This expresses acceleration in free space with uncertainty.

Accel accel

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x23, 0x0d, 0x51, 0xbd, 0x53, 0xbc, 0x36, 0xf2, 0x60, 0x57, 0x4e, 0x73, 0xb4, 0x29,
                0x41, 0xce, 0xfe, 0x44, 0x68, 0x47, 0x53, 0x48, 0x0b, 0x6f, 0xc3, 0x30, 0xc0, 0x32,
                0xc5, 0xdb, 0x59, 0x97,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::AccelWithCovariance_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct AccelWithCovarianceStamped {
            pub r#header: std_msgs::Header,
            pub r#accel: self::AccelWithCovariance,
        }
        impl ::roslibrust::RosMessageType for AccelWithCovarianceStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/AccelWithCovarianceStamped";
            const MD5SUM: &'static str = "85dc4e3c87dd8539dc32ab10fd048673";
            const DEFINITION: &'static str = r####"# This represents an estimated accel with reference coordinate frame and timestamp.
std_msgs/Header header
AccelWithCovariance accel
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/AccelWithCovariance
# This expresses acceleration in free space with uncertainty.

Accel accel

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Accel
# This expresses acceleration in free space broken into its linear and angular parts.
Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x61, 0xc9, 0xad, 0x89, 0x28, 0xe7, 0x1d, 0xd9, 0x5c, 0xe7, 0x91, 0xb2, 0xf0, 0x28,
                0x09, 0xee, 0x2a, 0x0b, 0xbc, 0xc4, 0x2c, 0xd0, 0xe4, 0x04, 0x7f, 0xd0, 0x0a, 0x82,
                0x2a, 0x08, 0xe4, 0x44,
            ];
            const ROS2_TYPE_NAME: &'static str =
                "geometry_msgs::msg::dds_::AccelWithCovarianceStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Inertia {
            pub r#m: f64,
            pub r#com: self::Vector3,
            pub r#ixx: f64,
            pub r#ixy: f64,
            pub r#ixz: f64,
            pub r#iyy: f64,
            pub r#iyz: f64,
            pub r#izz: f64,
        }
        impl ::roslibrust::RosMessageType for Inertia {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Inertia";
            const MD5SUM: &'static str = "1d26e4bb6c83ff141c5cf0d883c2b0fe";
            const DEFINITION: &'static str = r####"# Mass [kg]
float64 m

# Center of mass [m]
geometry_msgs/Vector3 com

# Inertia Tensor [kg-m^2]
#     | ixx ixy ixz |
# I = | ixy iyy iyz |
#     | ixz iyz izz |
float64 ixx
float64 ixy
float64 ixz
float64 iyy
float64 iyz
float64 izz
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x2d, 0xdd, 0x5d, 0xab, 0x5c, 0x34, 0x78, 0x25, 0xba, 0x2e, 0x56, 0xc8, 0x95, 0xdd,
                0xcc, 0xfd, 0x0b, 0x8e, 0xfe, 0x53, 0xae, 0x93, 0x1b, 0xf6, 0x7f, 0x90, 0x55, 0x29,
                0x93, 0x0b, 0x4b, 0xd7,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Inertia_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct InertiaStamped {
            pub r#header: std_msgs::Header,
            pub r#inertia: self::Inertia,
        }
        impl ::roslibrust::RosMessageType for InertiaStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/InertiaStamped";
            const MD5SUM: &'static str = "e5be6ffabc1d75f61d3105f562e8bc87";
            const DEFINITION: &'static str = r####"# An Inertia with a time stamp and reference frame.

std_msgs/Header header
Inertia inertia
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Inertia
# Mass [kg]
float64 m

# Center of mass [m]
geometry_msgs/Vector3 com

# Inertia Tensor [kg-m^2]
#     | ixx ixy ixz |
# I = | ixy iyy iyz |
#     | ixz iyz izz |
float64 ixx
float64 ixy
float64 ixz
float64 iyy
float64 iyz
float64 izz
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x76, 0x6b, 0xe4, 0x59, 0x76, 0x25, 0x2b, 0xab, 0xf7, 0xf9, 0xd8, 0xac, 0x4a, 0xe7,
                0xc9, 0x12, 0xa7, 0xce, 0xcc, 0xf7, 0x10, 0x35, 0x62, 0x25, 0x29, 0xf2, 0x75, 0x18,
                0xb6, 0x95, 0xaa, 0x09,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::InertiaStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Point {
            pub r#x: f64,
            pub r#y: f64,
            pub r#z: f64,
        }
        impl ::roslibrust::RosMessageType for Point {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Point";
            const MD5SUM: &'static str = "4a842b65f413084dc2b10fb484ea7f17";
            const DEFINITION: &'static str = r####"# This contains the position of a point in free space
float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x69, 0x63, 0x08, 0x48, 0x42, 0xa9, 0xb0, 0x44, 0x94, 0xd6, 0xb2, 0x94, 0x1d, 0x11,
                0x44, 0x47, 0x08, 0xd8, 0x92, 0xda, 0x2f, 0x4b, 0x09, 0x84, 0x3b, 0x9c, 0x43, 0xf4,
                0x2a, 0x7f, 0x68, 0x81,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Point_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Point32 {
            pub r#x: f32,
            pub r#y: f32,
            pub r#z: f32,
        }
        impl ::roslibrust::RosMessageType for Point32 {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Point32";
            const MD5SUM: &'static str = "cc153912f1453b708d221682bc23d9ac";
            const DEFINITION: &'static str = r####"# This contains the position of a point in free space(with 32 bits of precision).
# It is recommended to use Point wherever possible instead of Point32.
#
# This recommendation is to promote interoperability.
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.

float32 x
float32 y
float32 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x2f, 0xc4, 0xdb, 0x7c, 0xae, 0x16, 0xa4, 0x58, 0x2c, 0x79, 0xa5, 0x6b, 0x66, 0x17,
                0x3a, 0x8d, 0x48, 0xd5, 0x2c, 0x7d, 0xc5, 0x20, 0xdd, 0xc5, 0x5a, 0x0d, 0x4b, 0xcf,
                0x2a, 0x4b, 0xfd, 0xbc,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Point32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PointStamped {
            pub r#header: std_msgs::Header,
            pub r#point: self::Point,
        }
        impl ::roslibrust::RosMessageType for PointStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PointStamped";
            const MD5SUM: &'static str = "3dc055656bed5c4bb0657a41c8d46c59";
            const DEFINITION: &'static str = r####"# This represents a Point with reference coordinate frame and timestamp

std_msgs/Header header
Point point
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x4c, 0x02, 0x96, 0xaf, 0x86, 0xe0, 0x1e, 0x56, 0x2e, 0x9e, 0x04, 0x05, 0xd1, 0x38,
                0xa0, 0x15, 0x37, 0x24, 0x75, 0x80, 0x07, 0x6c, 0x58, 0xea, 0x38, 0xd7, 0x92, 0x3a,
                0xc1, 0x04, 0x58, 0x97,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PointStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Polygon {
            pub r#points: ::std::vec::Vec<self::Point32>,
        }
        impl ::roslibrust::RosMessageType for Polygon {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Polygon";
            const MD5SUM: &'static str = "cd60a26494a087f577976f0329fa120e";
            const DEFINITION: &'static str = r####"# A specification of a polygon where the first and last points are assumed to be connected

Point32[] points
================================================================================
MSG: geometry_msgs/Point32
# This contains the position of a point in free space(with 32 bits of precision).
# It is recommended to use Point wherever possible instead of Point32.
#
# This recommendation is to promote interoperability.
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.

float32 x
float32 y
float32 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x37, 0x82, 0xf9, 0xf0, 0xbf, 0x04, 0x49, 0x64, 0xd6, 0x92, 0xd6, 0xc0, 0x17, 0xd7,
                0x05, 0xe3, 0x76, 0x11, 0xaf, 0xb1, 0xf0, 0xbf, 0x6a, 0x9d, 0xee, 0x24, 0x8a, 0x7d,
                0xda, 0x0f, 0x78, 0x4a,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Polygon_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PolygonStamped {
            pub r#header: std_msgs::Header,
            pub r#polygon: self::Polygon,
        }
        impl ::roslibrust::RosMessageType for PolygonStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PolygonStamped";
            const MD5SUM: &'static str = "66ae3598ba9dd610ba674198e61d8fa7";
            const DEFINITION: &'static str = r####"# This represents a Polygon with reference coordinate frame and timestamp

std_msgs/Header header
Polygon polygon
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Point32
# This contains the position of a point in free space(with 32 bits of precision).
# It is recommended to use Point wherever possible instead of Point32.
#
# This recommendation is to promote interoperability.
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.

float32 x
float32 y
float32 z
================================================================================
MSG: geometry_msgs/Polygon
# A specification of a polygon where the first and last points are assumed to be connected

Point32[] points
================================================================================
MSG: geometry_msgs/Point32
# This contains the position of a point in free space(with 32 bits of precision).
# It is recommended to use Point wherever possible instead of Point32.
#
# This recommendation is to promote interoperability.
#
# This message is designed to take up less space when sending
# lots of points at once, as in the case of a PointCloud.

float32 x
float32 y
float32 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xb7, 0xcf, 0x07, 0x93, 0x2f, 0x15, 0x23, 0xd4, 0xb4, 0x08, 0x80, 0x75, 0x94, 0x5c,
                0x1a, 0x01, 0x41, 0xf7, 0xcd, 0x21, 0xda, 0x87, 0xcc, 0x94, 0x0f, 0xc6, 0x16, 0x52,
                0xe9, 0x13, 0x8b, 0x46,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PolygonStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Pose {
            pub r#position: self::Point,
            pub r#orientation: self::Quaternion,
        }
        impl ::roslibrust::RosMessageType for Pose {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Pose";
            const MD5SUM: &'static str = "e45d45a5a1ce597b249e23fb30fc871f";
            const DEFINITION: &'static str = r####"# A representation of pose in free space, composed of position and orientation.

Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xd5, 0x01, 0x95, 0x4e, 0x94, 0x76, 0xce, 0xa2, 0x99, 0x69, 0x84, 0xe8, 0x12, 0x05,
                0x4b, 0x68, 0x02, 0x6a, 0xe0, 0xbf, 0xae, 0x78, 0x9d, 0x9a, 0x10, 0xb2, 0x3d, 0xaf,
                0x35, 0xcc, 0x90, 0xfa,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Pose_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Pose2D {
            pub r#x: f64,
            pub r#y: f64,
            pub r#theta: f64,
        }
        impl ::roslibrust::RosMessageType for Pose2D {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Pose2D";
            const MD5SUM: &'static str = "938fa65709584ad8e77d238529be13b8";
            const DEFINITION: &'static str = r####"# Deprecated as of Foxy and will potentially be removed in any following release.
# Please use the full 3D pose.

# In general our recommendation is to use a full 3D representation of everything and for 2D specific applications make the appropriate projections into the plane for their calculations but optimally will preserve the 3D information during processing.

# If we have parallel copies of 2D datatypes every UI and other pipeline will end up needing to have dual interfaces to plot everything. And you will end up with not being able to use 3D tools for 2D use cases even if they're completely valid, as you'd have to reimplement it with different inputs and outputs. It's not particularly hard to plot the 2D pose or compute the yaw error for the Pose message and there are already tools and libraries that can do this for you.# This expresses a position and orientation on a 2D manifold.

float64 x
float64 y
float64 theta"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xd6, 0x8e, 0xfa, 0x5b, 0x46, 0xe7, 0x0f, 0x7b, 0x16, 0xca, 0x23, 0x08, 0x54, 0x74,
                0xfd, 0xac, 0x5a, 0x44, 0xb6, 0x38, 0x78, 0x3e, 0xc4, 0x2f, 0x66, 0x1d, 0xa6, 0x4d,
                0xa4, 0x72, 0x4c, 0xcc,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Pose2D_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseArray {
            pub r#header: std_msgs::Header,
            pub r#poses: ::std::vec::Vec<self::Pose>,
        }
        impl ::roslibrust::RosMessageType for PoseArray {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseArray";
            const MD5SUM: &'static str = "8f0f2bef738a5217c5210a25031dc811";
            const DEFINITION: &'static str = r####"# An array of poses with a header for global reference.

std_msgs/Header header

Pose[] poses
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation.

Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xaf, 0x0c, 0xc3, 0x6d, 0x19, 0x0e, 0x10, 0x4d, 0x54, 0x6d, 0x16, 0x8d, 0x6b, 0x39,
                0xdf, 0x04, 0xfa, 0x4b, 0x4c, 0xce, 0xcf, 0x59, 0xcb, 0x4c, 0x9e, 0xd3, 0x28, 0xd3,
                0xd5, 0x00, 0x4a, 0xa0,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PoseArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseStamped {
            pub r#header: std_msgs::Header,
            pub r#pose: self::Pose,
        }
        impl ::roslibrust::RosMessageType for PoseStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseStamped";
            const MD5SUM: &'static str = "5a783a9c53de9dbde905b1a8e1d332a6";
            const DEFINITION: &'static str = r####"# A Pose with reference coordinate frame and timestamp

std_msgs/Header header
Pose pose
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation.

Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x10, 0xf3, 0x78, 0x6d, 0x7d, 0x40, 0xfd, 0x2b, 0x54, 0x36, 0x78, 0x35, 0x61, 0x4b,
                0xff, 0x85, 0xd4, 0xad, 0x3b, 0x5d, 0xab, 0x62, 0xbf, 0x8b, 0xca, 0x0c, 0xc2, 0x32,
                0xd7, 0x3b, 0x4c, 0xd8,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PoseStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseWithCovariance {
            pub r#pose: self::Pose,
            #[default(_code = "[Default::default(); 36]")]
            #[serde(with = "::roslibrust::codegen::BigArray")]
            pub r#covariance: [f64; 36],
        }
        impl ::roslibrust::RosMessageType for PoseWithCovariance {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseWithCovariance";
            const MD5SUM: &'static str = "c23e848cf1b7533a8d7c259073a97e6f";
            const DEFINITION: &'static str = r####"# This represents a pose in free space with uncertainty.

Pose pose

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation.

Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x9a, 0x7c, 0x0f, 0xd2, 0x34, 0xb7, 0xf4, 0x5c, 0x60, 0x98, 0x74, 0x5e, 0xcc, 0xcd,
                0x77, 0x3c, 0xa1, 0x08, 0x56, 0x70, 0xe6, 0x41, 0x07, 0x13, 0x53, 0x97, 0xae, 0xe3,
                0x1c, 0x02, 0xe1, 0xbb,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::PoseWithCovariance_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct PoseWithCovarianceStamped {
            pub r#header: std_msgs::Header,
            pub r#pose: self::PoseWithCovariance,
        }
        impl ::roslibrust::RosMessageType for PoseWithCovarianceStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/PoseWithCovarianceStamped";
            const MD5SUM: &'static str = "c693703aeb65d31536e9f01ea76841e4";
            const DEFINITION: &'static str = r####"# This expresses an estimated pose with a reference coordinate frame and timestamp

std_msgs/Header header
PoseWithCovariance pose
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation.

Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/PoseWithCovariance
# This represents a pose in free space with uncertainty.

Pose pose

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Pose
# A representation of pose in free space, composed of position and orientation.

Point position
Quaternion orientation
================================================================================
MSG: geometry_msgs/Point
# This contains the position of a point in free space
float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x26, 0x43, 0x2f, 0x98, 0x03, 0xe4, 0x37, 0x27, 0xd3, 0xc8, 0xf6, 0x68, 0xd1, 0xfd,
                0xb3, 0xc6, 0x30, 0xf5, 0x48, 0xaf, 0x63, 0x1e, 0x2f, 0x4e, 0x31, 0x38, 0x23, 0x71,
                0xbf, 0xea, 0x3b, 0x6e,
            ];
            const ROS2_TYPE_NAME: &'static str =
                "geometry_msgs::msg::dds_::PoseWithCovarianceStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Quaternion {
            #[default(0f64)]
            pub r#x: f64,
            #[default(0f64)]
            pub r#y: f64,
            #[default(0f64)]
            pub r#z: f64,
            #[default(1f64)]
            pub r#w: f64,
        }
        impl ::roslibrust::RosMessageType for Quaternion {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Quaternion";
            const MD5SUM: &'static str = "a779879fadf0160734f906b8c19c7004";
            const DEFINITION: &'static str = r####"# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x8a, 0x76, 0x5f, 0x66, 0x77, 0x8c, 0x8f, 0xf7, 0xc8, 0xab, 0x94, 0xaf, 0xcc, 0x59,
                0x0a, 0x2e, 0xd5, 0x32, 0x5a, 0x1d, 0x9a, 0x07, 0x6f, 0xff, 0xf3, 0x8f, 0xbc, 0xe3,
                0x6f, 0x45, 0x86, 0x84,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Quaternion_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct QuaternionStamped {
            pub r#header: std_msgs::Header,
            pub r#quaternion: self::Quaternion,
        }
        impl ::roslibrust::RosMessageType for QuaternionStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/QuaternionStamped";
            const MD5SUM: &'static str = "6e3f7a64b8b509235ca9dc617a34bf93";
            const DEFINITION: &'static str = r####"# This represents an orientation with reference coordinate frame and timestamp.

std_msgs/Header header
Quaternion quaternion
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x38, 0x1a, 0xdd, 0x86, 0xc6, 0xc3, 0x16, 0x06, 0x44, 0xd2, 0x28, 0xca, 0x34, 0x21,
                0x82, 0xc7, 0xfd, 0x6c, 0x7f, 0xab, 0x11, 0xc7, 0xa8, 0x5a, 0xd8, 0x17, 0xa9, 0xcc,
                0x22, 0xdb, 0xac, 0x6e,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::QuaternionStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Transform {
            pub r#translation: self::Vector3,
            pub r#rotation: self::Quaternion,
        }
        impl ::roslibrust::RosMessageType for Transform {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Transform";
            const MD5SUM: &'static str = "ac9eff44abf714214112b05d54a3cf9b";
            const DEFINITION: &'static str = r####"# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xbe, 0xb8, 0x3f, 0xbe, 0x69, 0x86, 0x36, 0x35, 0x14, 0x61, 0xf6, 0xf3, 0x5d, 0x1a,
                0xbb, 0x20, 0x01, 0x0c, 0x43, 0xd5, 0x53, 0x74, 0xd8, 0x1b, 0xd0, 0x41, 0xf1, 0xba,
                0x25, 0x81, 0xfd, 0xdc,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Transform_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TransformStamped {
            pub r#header: std_msgs::Header,
            pub r#child_frame_id: ::std::string::String,
            pub r#transform: self::Transform,
        }
        impl ::roslibrust::RosMessageType for TransformStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TransformStamped";
            const MD5SUM: &'static str = "c555e99d9d1f7097738c8861133b3563";
            const DEFINITION: &'static str = r####"# This expresses a transform from coordinate frame header.frame_id
# to the coordinate frame child_frame_id at the time of header.stamp
#
# This message is mostly used by the
# <a href="https://index.ros.org/p/tf2/">tf2</a> package.
# See its documentation for more information.
#
# The child_frame_id is necessary in addition to the frame_id
# in the Header to communicate the full reference for the transform
# in a self contained message.

# The frame id in the header is used as the reference frame of this transform.
std_msgs/Header header

# The frame id of the child frame to which this transform points.
string child_frame_id

# Translation and rotation in 3-dimensions of child_frame_id from header.frame_id.
Transform transform
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Transform
# This represents the transform between two coordinate frames in free space.

Vector3 translation
Quaternion rotation
================================================================================
MSG: geometry_msgs/Quaternion
# This represents an orientation in free space in quaternion form.

float64 x 0
float64 y 0
float64 z 0
float64 w 1
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x0a, 0x24, 0x1f, 0x87, 0xd0, 0x46, 0x68, 0xd9, 0x40, 0x99, 0xcb, 0xb5, 0xba, 0x11,
                0x69, 0x1d, 0x5a, 0xd3, 0x2c, 0x2f, 0x29, 0x68, 0x2e, 0x4e, 0xb5, 0x65, 0x34, 0x24,
                0xbd, 0x27, 0x52, 0x06,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::TransformStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Twist {
            pub r#linear: self::Vector3,
            pub r#angular: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Twist {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Twist";
            const MD5SUM: &'static str = "9f195f881246fdfa2798d1d3eebca84a";
            const DEFINITION: &'static str = r####"# This expresses velocity in free space broken into its linear and angular parts.

Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x9c, 0x45, 0xbf, 0x16, 0xfe, 0x09, 0x83, 0xd8, 0x0e, 0x3c, 0xfe, 0x75, 0x0d, 0x68,
                0x35, 0x84, 0x3d, 0x26, 0x5a, 0x9a, 0x6c, 0x46, 0xbd, 0x2e, 0x60, 0x9f, 0xcd, 0xdd,
                0xe6, 0xfb, 0x8d, 0x2a,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Twist_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TwistStamped {
            pub r#header: std_msgs::Header,
            pub r#twist: self::Twist,
        }
        impl ::roslibrust::RosMessageType for TwistStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TwistStamped";
            const MD5SUM: &'static str = "7c6000d4f3aafa80eaf2471ce8172e85";
            const DEFINITION: &'static str = r####"# A twist with reference coordinate frame and timestamp

std_msgs/Header header
Twist twist
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.

Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x5f, 0x0f, 0xcd, 0x4f, 0x81, 0xd5, 0xd0, 0x6a, 0xd9, 0xb4, 0xc4, 0xc6, 0x3e, 0x3e,
                0xa5, 0x1b, 0x82, 0xd6, 0xae, 0x4d, 0x05, 0x58, 0xf1, 0xd4, 0x75, 0x22, 0x9b, 0x11,
                0x21, 0xdb, 0x6f, 0x64,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::TwistStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TwistWithCovariance {
            pub r#twist: self::Twist,
            #[default(_code = "[Default::default(); 36]")]
            #[serde(with = "::roslibrust::codegen::BigArray")]
            pub r#covariance: [f64; 36],
        }
        impl ::roslibrust::RosMessageType for TwistWithCovariance {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TwistWithCovariance";
            const MD5SUM: &'static str = "1fe8a28e6890a4cc3ae4c3ca5c7d82e6";
            const DEFINITION: &'static str = r####"# This expresses velocity in free space with uncertainty.

Twist twist

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.

Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x49, 0xf5, 0x74, 0xf0, 0x33, 0xf0, 0x95, 0xd8, 0xb6, 0xcd, 0x1b, 0xea, 0xca, 0x5c,
                0xa7, 0x92, 0x5e, 0x29, 0x6e, 0x84, 0xaf, 0x17, 0x16, 0xd1, 0x6c, 0x89, 0xd3, 0x8b,
                0x05, 0x9c, 0x8c, 0x18,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::TwistWithCovariance_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct TwistWithCovarianceStamped {
            pub r#header: std_msgs::Header,
            pub r#twist: self::TwistWithCovariance,
        }
        impl ::roslibrust::RosMessageType for TwistWithCovarianceStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/TwistWithCovarianceStamped";
            const MD5SUM: &'static str = "38d53b26c78ee3db59b20ff3e8127275";
            const DEFINITION: &'static str = r####"# This represents an estimated twist with reference coordinate frame and timestamp.

std_msgs/Header header
TwistWithCovariance twist
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.

Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/TwistWithCovariance
# This expresses velocity in free space with uncertainty.

Twist twist

# Row-major representation of the 6x6 covariance matrix
# The orientation parameters use a fixed-axis representation.
# In order, the parameters are:
# (x, y, z, rotation about X axis, rotation about Y axis, rotation about Z axis)
float64[36] covariance
================================================================================
MSG: geometry_msgs/Twist
# This expresses velocity in free space broken into its linear and angular parts.

Vector3  linear
Vector3  angular
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x77, 0xb6, 0x74, 0x34, 0x53, 0x1e, 0x65, 0x29, 0xb7, 0xa0, 0x09, 0x13, 0x57, 0xb1,
                0x86, 0xb6, 0xeb, 0xdb, 0x17, 0xfd, 0x9f, 0xfd, 0x3e, 0x0c, 0x7c, 0xe9, 0xd3, 0xfb,
                0x11, 0xa4, 0x45, 0x63,
            ];
            const ROS2_TYPE_NAME: &'static str =
                "geometry_msgs::msg::dds_::TwistWithCovarianceStamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Vector3 {
            pub r#x: f64,
            pub r#y: f64,
            pub r#z: f64,
        }
        impl ::roslibrust::RosMessageType for Vector3 {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Vector3";
            const MD5SUM: &'static str = "4a842b65f413084dc2b10fb484ea7f17";
            const DEFINITION: &'static str = r####"# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xcc, 0x12, 0xfe, 0x83, 0xe4, 0xc0, 0x27, 0x19, 0xf1, 0xce, 0x80, 0x70, 0xbf, 0xd1,
                0x4a, 0xec, 0xd4, 0x0f, 0x75, 0xa9, 0x66, 0x96, 0xa6, 0x7a, 0x2a, 0x1f, 0x37, 0xf7,
                0xdb, 0xb0, 0x76, 0x5d,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Vector3_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Vector3Stamped {
            pub r#header: std_msgs::Header,
            pub r#vector: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Vector3Stamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Vector3Stamped";
            const MD5SUM: &'static str = "13595660ee13403f23a0a2a0da07aa81";
            const DEFINITION: &'static str = r####"# This represents a Vector3 with reference coordinate frame and timestamp

# Note that this follows vector semantics with it always anchored at the origin,
# so the rotational elements of a transform are the only parts applied when transforming.

std_msgs/Header header
Vector3 vector
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xd4, 0x82, 0x96, 0x22, 0x28, 0x8c, 0xbb, 0x44, 0x38, 0x86, 0xe7, 0xea, 0x94, 0xea,
                0x56, 0x71, 0xa3, 0xb1, 0xbe, 0x6b, 0xab, 0x4a, 0xd0, 0x42, 0x24, 0x43, 0x2a, 0x65,
                0xf7, 0xd7, 0x88, 0x7a,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Vector3Stamped_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Wrench {
            pub r#force: self::Vector3,
            pub r#torque: self::Vector3,
        }
        impl ::roslibrust::RosMessageType for Wrench {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/Wrench";
            const MD5SUM: &'static str = "4f539cf138b23283b520fd271b567936";
            const DEFINITION: &'static str = r####"# This represents force in free space, separated into its linear and angular parts.

Vector3  force
Vector3  torque
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x01, 0x8e, 0x85, 0x19, 0xd5, 0x7c, 0x16, 0xad, 0xbe, 0x97, 0xc9, 0xfe, 0x14, 0x60,
                0xef, 0x21, 0xfe, 0xc7, 0xe3, 0x1b, 0xc5, 0x41, 0xde, 0x3d, 0x65, 0x3a, 0x35, 0x89,
                0x56, 0x77, 0xce, 0x52,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::Wrench_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct WrenchStamped {
            pub r#header: std_msgs::Header,
            pub r#wrench: self::Wrench,
        }
        impl ::roslibrust::RosMessageType for WrenchStamped {
            const ROS_TYPE_NAME: &'static str = "geometry_msgs/WrenchStamped";
            const MD5SUM: &'static str = "c7f9621a9f5013d52e82cd3c5d14f0fa";
            const DEFINITION: &'static str = r####"# A wrench with reference coordinate frame and timestamp

std_msgs/Header header
Wrench wrench
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: geometry_msgs/Wrench
# This represents force in free space, separated into its linear and angular parts.

Vector3  force
Vector3  torque
================================================================================
MSG: geometry_msgs/Vector3
# This represents a vector in free space.

# This is semantically different than a point.
# A vector is always anchored at the origin.
# When a transform is applied to a vector, only the rotational component is applied.

float64 x
float64 y
float64 z
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x8d, 0xc3, 0xde, 0xaf, 0x06, 0xb2, 0xab, 0x28, 0x1f, 0x9f, 0x9a, 0x74, 0x2a, 0x89,
                0x61, 0xc3, 0x28, 0xca, 0x7c, 0xec, 0x16, 0xe3, 0xfd, 0x65, 0x86, 0xd3, 0xa5, 0xc8,
                0x3f, 0xa7, 0x8f, 0x77,
            ];
            const ROS2_TYPE_NAME: &'static str = "geometry_msgs::msg::dds_::WrenchStamped_";
        }
    }
    #[allow(unused_imports)]
    pub mod service_msgs {
        use super::builtin_interfaces;
        use super::geometry_msgs;
        use super::std_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct ServiceEventInfo {
            pub r#event_type: u8,
            pub r#stamp: builtin_interfaces::Time,
            pub r#client_gid: [u8; 16],
            pub r#sequence_number: i64,
        }
        impl ::roslibrust::RosMessageType for ServiceEventInfo {
            const ROS_TYPE_NAME: &'static str = "service_msgs/ServiceEventInfo";
            const MD5SUM: &'static str = "42561fc0d0d3665a03d59fbb1296daf9";
            const DEFINITION: &'static str = r####"uint8 REQUEST_SENT = 0
uint8 REQUEST_RECEIVED = 1
uint8 RESPONSE_SENT = 2
uint8 RESPONSE_RECEIVED = 3

# The type of event this message represents
uint8 event_type

# Timestamp for when the event occurred (sent or received time)
builtin_interfaces/Time stamp

# Unique identifier for the client that sent the service request
# Note, this is only unique for the current session.
# The size here has to match the size of rmw_dds_common/msg/Gid,
# but unfortunately we cannot use that message directly due to a
# circular dependency.
char[16] client_gid

# Sequence number for the request
# Combined with the client ID, this creates a unique ID for the service transaction
int64 sequence_number
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x41, 0xbc, 0xbb, 0xe0, 0x7a, 0x75, 0xc9, 0xb5, 0x2b, 0xc9, 0x6b, 0xfd, 0x5c, 0x24,
                0xd7, 0xf0, 0xfc, 0x0a, 0x08, 0xc0, 0xcb, 0x79, 0x21, 0xb3, 0x37, 0x3c, 0x57, 0x32,
                0x34, 0x5a, 0x6f, 0x45,
            ];
            const ROS2_TYPE_NAME: &'static str = "service_msgs::msg::dds_::ServiceEventInfo_";
        }
        #[allow(unused)]
        impl ServiceEventInfo {
            pub const r#REQUEST_SENT: u8 = 0u8;
            pub const r#REQUEST_RECEIVED: u8 = 1u8;
            pub const r#RESPONSE_SENT: u8 = 2u8;
            pub const r#RESPONSE_RECEIVED: u8 = 3u8;
        }
    }
    #[allow(unused_imports)]
    pub mod std_msgs {
        use super::builtin_interfaces;
        use super::geometry_msgs;
        use super::service_msgs;
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Bool {
            pub r#data: bool,
        }
        impl ::roslibrust::RosMessageType for Bool {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Bool";
            const MD5SUM: &'static str = "8b94c1b53db61fb6aed406028ad6332a";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

bool data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xfe, 0xb9, 0x1e, 0x99, 0x5f, 0xf9, 0xeb, 0xd0, 0x9c, 0x0c, 0xb3, 0xd2, 0xae, 0xd1,
                0x8b, 0x11, 0x07, 0x75, 0x85, 0x83, 0x9f, 0xb5, 0xdb, 0x80, 0x19, 0x3b, 0x62, 0xd7,
                0x45, 0x28, 0xf6, 0xc9,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Bool_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Byte {
            pub r#data: u8,
        }
        impl ::roslibrust::RosMessageType for Byte {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Byte";
            const MD5SUM: &'static str = "ad736a2e8818154c487bb80fe42ce43b";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

byte data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xe2, 0x8c, 0xa2, 0xc6, 0x2f, 0x3f, 0xb1, 0x0c, 0x20, 0x78, 0x90, 0x75, 0x5a, 0xa7,
                0xa5, 0xa7, 0x70, 0xcc, 0xde, 0x56, 0x46, 0xfd, 0x66, 0xb4, 0x52, 0xf4, 0x85, 0xc4,
                0x80, 0x92, 0xf3, 0x27,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Byte_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct ByteMultiArray {
            pub r#layout: self::MultiArrayLayout,
            #[serde(with = "::roslibrust::codegen::serde_rosmsg_bytes")]
            pub r#data: ::std::vec::Vec<u8>,
        }
        impl ::roslibrust::RosMessageType for ByteMultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/ByteMultiArray";
            const MD5SUM: &'static str = "70ea476cbcfd65ac2f68f3cda1e891fe";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
byte[]            data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x69, 0x2e, 0xff, 0x26, 0xdd, 0x8c, 0xa7, 0x62, 0x3e, 0x4e, 0x90, 0xa0, 0x82, 0xf7,
                0xd8, 0x3f, 0x1c, 0xf5, 0xde, 0xb0, 0xb7, 0xba, 0x74, 0x8a, 0x2d, 0x4d, 0x5f, 0xbc,
                0xa7, 0x91, 0xdb, 0x7d,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::ByteMultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Char {
            pub r#data: u8,
        }
        impl ::roslibrust::RosMessageType for Char {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Char";
            const MD5SUM: &'static str = "1bf77f25acecdedba0e224b162199717";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

char data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x3a, 0xd2, 0xd0, 0x4d, 0xd2, 0x9b, 0xa1, 0x9d, 0x04, 0xb1, 0x66, 0x59, 0xaf, 0xa3,
                0xcc, 0xae, 0xdd, 0x69, 0x19, 0x14, 0xb0, 0x2a, 0x64, 0xe8, 0x2e, 0x25, 0x2f, 0x2f,
                0xa6, 0xa5, 0x86, 0xa9,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Char_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct ColorRGBA {
            pub r#r: f32,
            pub r#g: f32,
            pub r#b: f32,
            pub r#a: f32,
        }
        impl ::roslibrust::RosMessageType for ColorRGBA {
            const ROS_TYPE_NAME: &'static str = "std_msgs/ColorRGBA";
            const MD5SUM: &'static str = "a29a96539573343b1310c73607334b00";
            const DEFINITION: &'static str = r####"float32 r
float32 g
float32 b
float32 a"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x77, 0xa7, 0xa5, 0xb9, 0xae, 0x47, 0x73, 0x06, 0x09, 0x76, 0x65, 0x10, 0x6e, 0x04,
                0x13, 0xba, 0x74, 0x44, 0x02, 0x45, 0xb1, 0xf3, 0xd0, 0xc6, 0xd6, 0x40, 0x5f, 0xe5,
                0xc7, 0x81, 0x3f, 0xe8,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::ColorRGBA_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Empty {}
        impl ::roslibrust::RosMessageType for Empty {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Empty";
            const MD5SUM: &'static str = "d41d8cd98f00b204e9800998ecf8427e";
            const DEFINITION: &'static str = r####""####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x20, 0xb6, 0x25, 0x25, 0x6f, 0x32, 0xd5, 0xdb, 0xc0, 0xd0, 0x4f, 0xee, 0x44, 0xf4,
                0x3c, 0x41, 0xe5, 0x1c, 0x70, 0xd3, 0x50, 0x2f, 0x84, 0xb4, 0xa0, 0x8e, 0x7a, 0x9c,
                0x26, 0xa9, 0x63, 0x12,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Empty_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float32 {
            pub r#data: f32,
        }
        impl ::roslibrust::RosMessageType for Float32 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float32";
            const MD5SUM: &'static str = "73fcbf46b49191e672908e50842a83d4";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

float32 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x71, 0x70, 0xd3, 0xd8, 0xf8, 0x41, 0xf7, 0xbe, 0x31, 0x72, 0xce, 0x5f, 0x4f, 0x59,
                0xf3, 0xa4, 0xd7, 0xf6, 0x3b, 0x04, 0x47, 0xe8, 0xb3, 0x33, 0x27, 0x60, 0x1a, 0xd6,
                0x4d, 0x83, 0xd6, 0xe2,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float32MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<f32>,
        }
        impl ::roslibrust::RosMessageType for Float32MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float32MultiArray";
            const MD5SUM: &'static str = "6a40e0ffa6a17a503ac3f8616991b1f6";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float32[]         data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x05, 0x99, 0xf6, 0xf8, 0x5b, 0x4b, 0xfc, 0xa3, 0x79, 0x87, 0x3a, 0x0b, 0x43, 0x75,
                0xa0, 0xac, 0xa0, 0x22, 0x15, 0x6b, 0xd2, 0xd7, 0x02, 0x12, 0x75, 0xd1, 0x16, 0xed,
                0x1f, 0xa8, 0xbf, 0xe0,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float32MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float64 {
            pub r#data: f64,
        }
        impl ::roslibrust::RosMessageType for Float64 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float64";
            const MD5SUM: &'static str = "fdb28210bfa9d7c91146260178d9a584";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

float64 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x70, 0x5b, 0xa9, 0xc3, 0xd1, 0xa0, 0x9d, 0xf4, 0x37, 0x37, 0xeb, 0x67, 0x09, 0x55,
                0x34, 0xde, 0x36, 0xfd, 0x42, 0x6c, 0x05, 0x87, 0x77, 0x9b, 0xda, 0x2b, 0xc5, 0x1f,
                0xe7, 0x90, 0x18, 0x2a,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float64_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Float64MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<f64>,
        }
        impl ::roslibrust::RosMessageType for Float64MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Float64MultiArray";
            const MD5SUM: &'static str = "4b7d974086d4060e7db4613a7e6c3ba4";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
float64[]         data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x10, 0x25, 0xdd, 0xc6, 0xb9, 0x55, 0x2d, 0x19, 0x1f, 0x89, 0xef, 0x1a, 0x8d, 0x2f,
                0x60, 0xf3, 0xd3, 0x73, 0xe2, 0x8b, 0x28, 0x3d, 0x88, 0x91, 0xdd, 0xcc, 0x97, 0x4e,
                0x8c, 0x55, 0x39, 0x7f,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Float64MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Header {
            pub r#stamp: builtin_interfaces::Time,
            pub r#frame_id: ::std::string::String,
        }
        impl ::roslibrust::RosMessageType for Header {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Header";
            const MD5SUM: &'static str = "3cca5e8ccb31a32fff4058beb6f250e3";
            const DEFINITION: &'static str = r####"# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data
# in a particular coordinate frame.

# Two-integer timestamp that is expressed as seconds and nanoseconds.
builtin_interfaces/Time stamp

# Transform frame with which this data is associated.
string frame_id
================================================================================
MSG: builtin_interfaces/Time
# This message communicates ROS Time defined here:
# https://design.ros2.org/articles/clock_and_time.html

# The seconds component, valid over all int32 values.
int32 sec

# The nanoseconds component, valid in the range [0, 1e9), to be added to the seconds component. 
# e.g.
# The time -1.7 seconds is represented as {sec: -2, nanosec: 3e8}
# The time 1.7 seconds is represented as {sec: 1, nanosec: 7e8}
uint32 nanosec"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xf4, 0x9f, 0xb3, 0xae, 0x2c, 0xf0, 0x70, 0xf7, 0x93, 0x64, 0x5f, 0xf7, 0x49, 0x68,
                0x3a, 0xc6, 0xb0, 0x62, 0x03, 0xe4, 0x1c, 0x89, 0x1e, 0x17, 0x70, 0x1b, 0x1c, 0xb5,
                0x97, 0xce, 0x6a, 0x01,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Header_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int16 {
            pub r#data: i16,
        }
        impl ::roslibrust::RosMessageType for Int16 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int16";
            const MD5SUM: &'static str = "8524586e34fbd7cb1c08c5f5f1ca0e57";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

int16 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x1d, 0xcc, 0x34, 0x64, 0xe4, 0x7c, 0x28, 0x8a, 0x55, 0xf9, 0x43, 0xa3, 0x89, 0xd3,
                0x37, 0xcd, 0xb0, 0x68, 0x04, 0xde, 0x3f, 0x5c, 0xd7, 0xa2, 0x66, 0xb0, 0xde, 0x71,
                0x8e, 0xee, 0x17, 0xe5,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int16_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int16MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i16>,
        }
        impl ::roslibrust::RosMessageType for Int16MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int16MultiArray";
            const MD5SUM: &'static str = "d9338d7f523fcb692fae9d0a0e9f067c";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int16[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xb5, 0x88, 0x10, 0xe8, 0xe5, 0xb9, 0x0f, 0xb1, 0x9a, 0x50, 0x62, 0x46, 0x9e, 0xb8,
                0x40, 0x9f, 0x5a, 0xb1, 0x1a, 0x44, 0x6d, 0x60, 0xde, 0x71, 0x57, 0xa1, 0x45, 0x7e,
                0x52, 0xa0, 0x76, 0xce,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int16MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int32 {
            pub r#data: i32,
        }
        impl ::roslibrust::RosMessageType for Int32 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int32";
            const MD5SUM: &'static str = "da5909fbe378aeaf85e547e830cc1bb7";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

int32 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xb6, 0x57, 0x8d, 0xed, 0x3c, 0x58, 0xc6, 0x26, 0xcf, 0xe8, 0xd1, 0xa6, 0xfb, 0x6e,
                0x04, 0xf7, 0x06, 0xf9, 0x7e, 0x9f, 0x03, 0xd2, 0x72, 0x7c, 0x9f, 0xf4, 0xe7, 0x4b,
                0x1c, 0xef, 0x0d, 0xeb,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int32MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i32>,
        }
        impl ::roslibrust::RosMessageType for Int32MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int32MultiArray";
            const MD5SUM: &'static str = "1d99f79f8b325b44fee908053e9c945b";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int32[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x84, 0xa7, 0x34, 0x63, 0x23, 0x52, 0x5d, 0x1b, 0x4d, 0xfc, 0xa8, 0x99, 0xdf, 0x38,
                0x20, 0xf2, 0x45, 0xe5, 0x40, 0x09, 0xda, 0xc5, 0xa6, 0xb6, 0x92, 0x17, 0xd1, 0x4f,
                0xde, 0xfd, 0x17, 0x01,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int32MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int64 {
            pub r#data: i64,
        }
        impl ::roslibrust::RosMessageType for Int64 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int64";
            const MD5SUM: &'static str = "34add168574510e6e17f5d23ecc077ef";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

int64 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x8c, 0xd1, 0x04, 0x8c, 0x2f, 0x18, 0x6b, 0x6b, 0xd9, 0xa9, 0x24, 0x72, 0xdc, 0x1c,
                0xe5, 0x17, 0x23, 0xc0, 0x83, 0x3a, 0x22, 0x1e, 0x2b, 0x7a, 0xec, 0xff, 0xf1, 0x11,
                0x77, 0x4f, 0x4b, 0x49,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int64_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int64MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i64>,
        }
        impl ::roslibrust::RosMessageType for Int64MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int64MultiArray";
            const MD5SUM: &'static str = "54865aa6c65be0448113a2afc6a49270";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int64[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xe6, 0x0f, 0x9f, 0xe3, 0x4d, 0x69, 0x7f, 0x09, 0x39, 0xad, 0x49, 0xd3, 0x31, 0x58,
                0x69, 0x3c, 0x12, 0x77, 0xfb, 0xac, 0x0e, 0x2f, 0x04, 0xb7, 0xc2, 0x99, 0x5d, 0xc2,
                0x1c, 0x89, 0xb4, 0x22,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int64MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int8 {
            pub r#data: i8,
        }
        impl ::roslibrust::RosMessageType for Int8 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int8";
            const MD5SUM: &'static str = "27ffa0c9c4b8fb8492252bcad9e5c57b";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

int8 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x26, 0x52, 0x50, 0x65, 0xa4, 0x03, 0xd9, 0x72, 0xcb, 0x67, 0x2f, 0x07, 0x77, 0xe3,
                0x33, 0xf0, 0xc7, 0x99, 0xad, 0x44, 0x4a, 0xe5, 0xfc, 0xd7, 0x9e, 0x43, 0xd1, 0xe7,
                0x3b, 0xd0, 0xf4, 0x40,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int8_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct Int8MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<i8>,
        }
        impl ::roslibrust::RosMessageType for Int8MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/Int8MultiArray";
            const MD5SUM: &'static str = "d7c1af35a1b4781bbe79e03dd94b7c13";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
int8[]            data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xf2, 0x19, 0x98, 0xd4, 0xb4, 0x92, 0xab, 0xd6, 0x33, 0x30, 0x76, 0x5d, 0x75, 0xd5,
                0x83, 0x12, 0x38, 0xd4, 0x00, 0x74, 0x03, 0x86, 0xf6, 0x51, 0xf1, 0x3a, 0x87, 0x2a,
                0x4d, 0x21, 0x88, 0xdb,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::Int8MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct MultiArrayDimension {
            pub r#label: ::std::string::String,
            pub r#size: u32,
            pub r#stride: u32,
        }
        impl ::roslibrust::RosMessageType for MultiArrayDimension {
            const ROS_TYPE_NAME: &'static str = "std_msgs/MultiArrayDimension";
            const MD5SUM: &'static str = "4cd0c83a8683deae40ecdac60e53bfa8";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x5e, 0x77, 0x3a, 0x60, 0xa4, 0xc7, 0xfc, 0x8a, 0x54, 0x98, 0x5f, 0x30, 0x7c, 0x78,
                0x37, 0xaa, 0x29, 0x94, 0x25, 0x2a, 0x12, 0x6c, 0x30, 0x19, 0x57, 0xa2, 0x4e, 0x31,
                0x28, 0x2c, 0x9c, 0xbe,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::MultiArrayDimension_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct MultiArrayLayout {
            pub r#dim: ::std::vec::Vec<self::MultiArrayDimension>,
            pub r#data_offset: u32,
        }
        impl ::roslibrust::RosMessageType for MultiArrayLayout {
            const ROS_TYPE_NAME: &'static str = "std_msgs/MultiArrayLayout";
            const MD5SUM: &'static str = "0fed2a11c13e11c5571b4e2a995a91a3";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x4c, 0x66, 0xe6, 0xf7, 0x8e, 0x74, 0x0a, 0xc1, 0x03, 0xa9, 0x4c, 0xf6, 0x32, 0x59,
                0xf9, 0x68, 0xe4, 0x8c, 0x61, 0x7e, 0x76, 0x99, 0xe8, 0x29, 0xb6, 0x3c, 0x21, 0xa5,
                0xcb, 0x50, 0xda, 0xc6,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::MultiArrayLayout_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct String {
            pub r#data: ::std::string::String,
        }
        impl ::roslibrust::RosMessageType for String {
            const ROS_TYPE_NAME: &'static str = "std_msgs/String";
            const MD5SUM: &'static str = "992ce8a1687cec8c8bd883ec73ca41d1";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xdf, 0x66, 0x8c, 0x74, 0x04, 0x82, 0xbb, 0xd4, 0x8f, 0xb3, 0x9d, 0x76, 0xa7, 0x0d,
                0xfd, 0x4b, 0xd5, 0x9d, 0xb1, 0x28, 0x80, 0x21, 0x74, 0x35, 0x03, 0x25, 0x9e, 0x94,
                0x8f, 0x6b, 0x1a, 0x18,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::String_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt16 {
            pub r#data: u16,
        }
        impl ::roslibrust::RosMessageType for UInt16 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt16";
            const MD5SUM: &'static str = "1df79edf208b629fe6b81923a544552d";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

uint16 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x08, 0xa4, 0x06, 0xe4, 0xb0, 0x22, 0xbc, 0x22, 0xe9, 0x07, 0xf9, 0x85, 0xd6, 0xa9,
                0xe9, 0xdd, 0x1d, 0x4f, 0xbe, 0xca, 0xe5, 0x73, 0x54, 0x9c, 0xf4, 0x93, 0x50, 0x11,
                0x3e, 0x77, 0x57, 0xb1,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt16_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt16MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<u16>,
        }
        impl ::roslibrust::RosMessageType for UInt16MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt16MultiArray";
            const MD5SUM: &'static str = "52f264f1c973c4b73790d384c6cb4484";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint16[]            data        # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x94, 0xfe, 0x73, 0x42, 0x8e, 0xc6, 0x3b, 0xae, 0xcc, 0x77, 0x4f, 0x8f, 0xb8, 0x24,
                0x06, 0x12, 0x3e, 0x92, 0x91, 0xcf, 0x72, 0x8f, 0x1b, 0x7c, 0x91, 0xca, 0xf5, 0x33,
                0x51, 0x29, 0x49, 0x2b,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt16MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt32 {
            pub r#data: u32,
        }
        impl ::roslibrust::RosMessageType for UInt32 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt32";
            const MD5SUM: &'static str = "304a39449588c7f8ce2df6e8001c5fce";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

uint32 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xa5, 0xc8, 0x74, 0x82, 0x9b, 0x75, 0x2b, 0xc5, 0xfa, 0x19, 0x00, 0x24, 0xb0, 0xad,
                0x76, 0xf5, 0x78, 0xcc, 0x27, 0x82, 0x71, 0xe8, 0x55, 0xc7, 0xd0, 0x2a, 0x81, 0x8b,
                0x35, 0x16, 0xfb, 0x4a,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt32_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt32MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<u32>,
        }
        impl ::roslibrust::RosMessageType for UInt32MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt32MultiArray";
            const MD5SUM: &'static str = "4d6a180abc9be191b96a7eda6c8a233d";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint32[]          data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x6c, 0x25, 0x77, 0xc7, 0xad, 0x3c, 0xbd, 0xcc, 0x21, 0x64, 0xa4, 0x1c, 0x12, 0xf1,
                0xd5, 0xad, 0x31, 0x4e, 0xa3, 0x20, 0xf3, 0xfb, 0x1e, 0xe4, 0x7e, 0x78, 0x01, 0x9f,
                0xe1, 0x6b, 0xb5, 0xb0,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt32MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt64 {
            pub r#data: u64,
        }
        impl ::roslibrust::RosMessageType for UInt64 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt64";
            const MD5SUM: &'static str = "1b2a79973e8bf53d7b53acb71299cb57";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

uint64 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xfb, 0xdc, 0x52, 0x01, 0x8f, 0xc1, 0x37, 0x55, 0xdc, 0xe1, 0x80, 0x24, 0xd1, 0xa6,
                0x71, 0xc8, 0x56, 0xaa, 0x8b, 0x4a, 0xaf, 0x63, 0xad, 0xfb, 0x09, 0x5b, 0x60, 0x8f,
                0x98, 0xe8, 0xc9, 0x43,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt64_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt64MultiArray {
            pub r#layout: self::MultiArrayLayout,
            pub r#data: ::std::vec::Vec<u64>,
        }
        impl ::roslibrust::RosMessageType for UInt64MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt64MultiArray";
            const MD5SUM: &'static str = "6088f127afb1d6c72927aa1247e945af";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint64[]          data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0xfc, 0x1c, 0x68, 0x5c, 0x2f, 0x76, 0xbd, 0xc6, 0x98, 0x3d, 0xa0, 0x25, 0xcb, 0x25,
                0xd2, 0xdb, 0x5f, 0xb5, 0x15, 0x7b, 0x05, 0x9e, 0x30, 0x0f, 0x6d, 0x95, 0x7d, 0x86,
                0xf9, 0x81, 0xb3, 0x66,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt64MultiArray_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt8 {
            pub r#data: u8,
        }
        impl ::roslibrust::RosMessageType for UInt8 {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt8";
            const MD5SUM: &'static str = "7c8164229e7d2c17eb95e9231617fdee";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

uint8 data"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x61, 0x38, 0xbd, 0x83, 0xd8, 0xc3, 0x56, 0x9c, 0xb8, 0x0a, 0x66, 0x7d, 0xb0, 0x3c,
                0xfc, 0x16, 0x29, 0xf5, 0x29, 0xfe, 0xe7, 0x9d, 0x94, 0x4c, 0x39, 0xc3, 0x4e, 0x35,
                0x2e, 0x72, 0xf0, 0x10,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt8_";
        }
        #[allow(non_snake_case)]
        #[allow(dead_code)]
        #[derive(
            :: roslibrust :: codegen :: Deserialize,
            :: roslibrust :: codegen :: Serialize,
            :: roslibrust :: codegen :: SmartDefault,
            Debug,
            Clone,
            PartialEq,
        )]
        #[serde(crate = "::roslibrust::codegen::serde")]
        pub struct UInt8MultiArray {
            pub r#layout: self::MultiArrayLayout,
            #[serde(with = "::roslibrust::codegen::serde_rosmsg_bytes")]
            pub r#data: ::std::vec::Vec<u8>,
        }
        impl ::roslibrust::RosMessageType for UInt8MultiArray {
            const ROS_TYPE_NAME: &'static str = "std_msgs/UInt8MultiArray";
            const MD5SUM: &'static str = "82373f1612381bb6ee473b5cd6f5d89c";
            const DEFINITION: &'static str = r####"# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# Please look at the MultiArrayLayout message definition for
# documentation on all multiarrays.

MultiArrayLayout  layout        # specification of data layout
uint8[]           data          # array of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension
================================================================================
MSG: std_msgs/MultiArrayLayout
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

# The multiarray declares a generic multi-dimensional array of a
# particular data type.  Dimensions are ordered from outer most
# to inner most.
#
# Accessors should ALWAYS be written in terms of dimension stride
# and specified outer-most dimension first.
#
# multiarray(i,j,k) = data[data_offset + dim_stride[1]*i + dim_stride[2]*j + k]
#
# A standard, 3-channel 640x480 image with interleaved color channels
# would be specified as:
#
# dim[0].label  = "height"
# dim[0].size   = 480
# dim[0].stride = 3*640*480 = 921600  (note dim[0] stride is just size of image)
# dim[1].label  = "width"
# dim[1].size   = 640
# dim[1].stride = 3*640 = 1920
# dim[2].label  = "channel"
# dim[2].size   = 3
# dim[2].stride = 3
#
# multiarray(i,j,k) refers to the ith row, jth column, and kth channel.

MultiArrayDimension[] dim # Array of dimension properties
uint32 data_offset        # padding bytes at front of data
================================================================================
MSG: std_msgs/MultiArrayDimension
# This was originally provided as an example message.
# It is deprecated as of Foxy
# It is recommended to create your own semantically meaningful message.
# However if you would like to continue using this please use the equivalent in example_msgs.

string label   # label of given dimension
uint32 size    # size of given dimension (in type units)
uint32 stride  # stride of given dimension"####;
            const ROS2_HASH: &'static [u8; 32] = &[
                0x56, 0x87, 0xe8, 0x61, 0xb8, 0xd3, 0x07, 0xa5, 0xe4, 0x8b, 0x75, 0x15, 0x46, 0x7a,
                0xe7, 0xa5, 0xfc, 0x2d, 0xaf, 0x80, 0x5b, 0xd0, 0xce, 0x6d, 0x8e, 0x9e, 0x60, 0x4b,
                0xad, 0xe9, 0xf3, 0x85,
            ];
            const ROS2_TYPE_NAME: &'static str = "std_msgs::msg::dds_::UInt8MultiArray_";
        }
    }

    /// TFMessage is the message type published on /tf and /tf_static topics.
    /// It contains an array of geometry_msgs/TransformStamped messages.
    #[allow(non_snake_case)]
    #[derive(
        ::serde::Deserialize,
        ::serde::Serialize,
        ::roslibrust::codegen::SmartDefault,
        Debug,
        Clone,
        PartialEq,
    )]
    pub struct TFMessage {
        pub transforms: Vec<geometry_msgs::TransformStamped>,
    }

    impl ::roslibrust_common::RosMessageType for TFMessage {
        const ROS_TYPE_NAME: &'static str = "tf2_msgs/TFMessage";
        const MD5SUM: &'static str = "94810edda583a504dfda3829e70d7eec";
        const DEFINITION: &'static str = "geometry_msgs/TransformStamped[] transforms";
        const ROS2_HASH: &'static [u8; 32] = &[
            0x84, 0x64, 0x1e, 0xf6, 0x1a, 0x5a, 0xa7, 0xf4, 0x9e, 0x8f, 0xc3, 0xca, 0x2f, 0x3c,
            0xf7, 0x3e, 0x24, 0x3a, 0x50, 0x7c, 0xc6, 0x5a, 0x6b, 0x93, 0xe4, 0x1a, 0xa3, 0x57,
            0x83, 0xd1, 0x94, 0x71,
        ];
        const ROS2_TYPE_NAME: &'static str = "tf2_msgs::msg::dds_::TFMessage_";
    }
}
