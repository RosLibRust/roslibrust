use log::*;
use roslibrust_common::*;
use std::result::Result as StdResult;

use ros_z::{
    context::ZContext,
    entity::{TypeHash, TypeInfo},
    msg::ZService,
    pubsub::{ZPub, ZSub},
    ros_msg::{ServiceTypeInfo, WithTypeInfo},
    Builder,
};

/// re-export ros_z for consumers
pub use ros_z;

/// Wrapper type that implements WithTypeInfo for RosMessageType
/// This allows RosMessageType implementations to work with ros-z's type system
pub struct RosMessageWrapper<T: RosMessageType>(pub T);

impl<T: RosMessageType> ros_z::ros_msg::MessageTypeInfo for RosMessageWrapper<T> {
    fn type_name() -> &'static str {
        T::ROS2_TYPE_NAME
    }

    fn type_hash() -> TypeHash {
        TypeHash::new(1, *T::ROS2_HASH)
    }
}

impl<T: RosMessageType> WithTypeInfo for RosMessageWrapper<T> {}

// Custom serializer that treats RosMessageWrapper<T> as T for serialization purposes
pub struct WrapperSerdes<T: RosMessageType>(std::marker::PhantomData<T>);

impl<T: RosMessageType> ros_z::msg::ZSerializer for WrapperSerdes<T> {
    type Input<'a> = &'a RosMessageWrapper<T>;
    fn serialize(input: Self::Input<'_>) -> Vec<u8> {
        ros_z::msg::CdrSerdes::<T>::serialize(&input.0)
    }
}

impl<T: RosMessageType> ros_z::msg::ZDeserializer for WrapperSerdes<T> {
    type Input<'a> = &'a [u8];
    type Output = RosMessageWrapper<T>;
    fn deserialize(data: Self::Input<'_>) -> Self::Output {
        let inner = ros_z::msg::CdrSerdes::<T>::deserialize(data);
        RosMessageWrapper(inner)
    }
}

impl<T: RosMessageType> ros_z::msg::ZMessage for RosMessageWrapper<T> {
    type Serdes = WrapperSerdes<T>;
}

/// A "newtype" wrapper around ZNode so we can implement roslibrust's traits for it.
pub struct ZenohClient {
    // TODO: We'll probably end up wrapping node in an Arc<> so we can make this clone for users
    node: ros_z::node::ZNode,
}

// A "newtype" wrapper around ZPub so we can implement roslibrust's traits for it.
/// The publisher type returned by [TopicProvider::advertise] on [ZenohClient].
/// This type is self de-registering, and dropping the publisher will automatically un-advertise the topic.
/// This type is generic on the message type that will be published.
pub struct ZenohPublisher<T: RosMessageType> {
    publisher: ZPub<RosMessageWrapper<T>, WrapperSerdes<T>>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Publish<T> for ZenohPublisher<T> {
    async fn publish(&self, data: &T) -> Result<()> {
        self.publisher
            .async_publish(&RosMessageWrapper(data.clone()))
            .await
            // TODO: should work on error type here with ros_z team
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))
    }
}

/// The subscriber type returned by [TopicProvider::subscribe] on [ZenohClient].
/// This type is self de-registering, and dropping the subscriber will automatically unsubscribe from the topic.
/// This type is generic on the message type that will be received.
/// It is typically used with types generated by roslibrust's codegen.
pub struct ZenohSubscriber<T: RosMessageType> {
    subscriber: ZSub<RosMessageWrapper<T>, zenoh::sample::Sample, WrapperSerdes<T>>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Subscribe<T> for ZenohSubscriber<T> {
    async fn next(&mut self) -> Result<T> {
        let next = self.subscriber.async_recv().await;
        let msg = next.map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;
        Ok(msg.0)
    }
}

impl ZenohClient {
    // TODO don't love error type here... could work with ros_z to get better errors
    /// Creates a new node with the specified name and return a handle to it.
    pub async fn new(
        ctx: &ZContext,
        name: impl AsRef<str>,
    ) -> StdResult<Self, Box<dyn std::error::Error + Send + Sync + 'static>> {
        let node = ctx.create_node(name.as_ref()).build()?;
        Ok(Self { node })
    }
}

impl roslibrust_common::TopicProvider for ZenohClient {
    type Publisher<T: RosMessageType> = ZenohPublisher<T>;
    type Subscriber<T: RosMessageType> = ZenohSubscriber<T>;

    async fn advertise<T: RosMessageType>(&self, topic: &str) -> Result<Self::Publisher<T>> {
        let publisher = self
            .node
            .create_pub::<RosMessageWrapper<T>>(topic)
            .with_serdes::<WrapperSerdes<T>>()
            .build()
            // TODO better errors
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        Ok(ZenohPublisher {
            publisher,
            _marker: std::marker::PhantomData,
        })
    }

    async fn subscribe<T: RosMessageType>(&self, topic: &str) -> Result<Self::Subscriber<T>> {
        let sub = self
            .node
            .create_sub::<RosMessageWrapper<T>>(topic)
            .with_serdes::<WrapperSerdes<T>>()
            .build()
            // TODO better errors
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        Ok(ZenohSubscriber {
            subscriber: sub,
            _marker: std::marker::PhantomData,
        })
    }
}

// TODO MAJOR: problem here ZService trait can't be implemented for our example messages due to orphan rule...
// Have to do some gross work around to get roslibrust::RosServiceType and ros_z::ZService to play nicely together
pub struct ZenohServiceServer {
    // Used to shutdown server task when dropped
    cancellation_token: tokio_util::sync::CancellationToken,
}

impl Drop for ZenohServiceServer {
    fn drop(&mut self) {
        self.cancellation_token.cancel();
    }
}

pub struct ZenohServiceClient<T: RosServiceType> {
    client: ros_z::service::ZClient<Fake<T>>,
    _marker: std::marker::PhantomData<T>,
}

// Helper struct to work around orphan rule
struct Fake<T>(std::marker::PhantomData<T>);
impl<T: RosServiceType> ZService for Fake<T> {
    type Request = T::Request;
    type Response = T::Response;
}

impl<T: RosServiceType> ServiceTypeInfo for Fake<T> {
    fn service_type_info() -> TypeInfo {
        TypeInfo::new(T::ROS2_TYPE_NAME, TypeHash::new(1, *T::ROS2_HASH))
    }
}

impl<T: RosServiceType> roslibrust_common::Service<T> for ZenohServiceClient<T> {
    async fn call(&self, request: &T::Request) -> Result<T::Response> {
        // Send the request
        self.client
            .send_request(request)
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        // Wait for and take the response
        let response = self
            .client
            .take_response()
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        Ok(response)
    }
}

impl roslibrust_common::ServiceProvider for ZenohClient {
    type ServiceClient<T: RosServiceType> = ZenohServiceClient<T>;
    type ServiceServer = ZenohServiceServer;

    async fn call_service<T: RosServiceType>(
        &self,
        topic: &str,
        request: T::Request,
    ) -> Result<T::Response> {
        // Create a service client and call it once
        let client = self.service_client::<T>(topic).await?;
        client.call(&request).await
    }

    async fn service_client<T: RosServiceType + 'static>(
        &self,
        topic: &str,
    ) -> Result<Self::ServiceClient<T>> {
        let client = self
            .node
            .create_client::<Fake<T>>(topic)
            .build()
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        Ok(ZenohServiceClient {
            client,
            _marker: std::marker::PhantomData,
        })
    }

    async fn advertise_service<T: RosServiceType + 'static, F>(
        &self,
        topic: &str,
        server: F,
    ) -> Result<Self::ServiceServer>
    where
        F: ServiceFn<T>,
    {
        // TODO: doing some really dome stuff here... to work around orphan rule and RosServiceType != ZService
        struct Fake<T>(T);
        impl<T: RosServiceType> ZService for Fake<T> {
            type Request = T::Request;
            type Response = T::Response;
        }
        impl<T: RosServiceType> ServiceTypeInfo for Fake<T> {
            fn service_type_info() -> TypeInfo {
                TypeInfo::new(T::ROS2_TYPE_NAME, TypeHash::new(1, *T::ROS2_HASH))
            }
        }

        let mut service = self
            .node
            .create_service::<Fake<T>>(topic)
            .build()
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        let cancellation_token = tokio_util::sync::CancellationToken::new();

        // Build a clone wrapper for the users's function
        let server = std::sync::Arc::new(server);
        let topic = topic.to_string();
        let ct_copy = cancellation_token.clone();
        tokio::spawn(async move {
            let body_future = async {
                loop {
                    let req = service.take_request_async().await;
                    let (query, req) = match req {
                        Ok(req) => req,
                        Err(e) => {
                            error!("Failed to take request in service {topic}: {e:?}");
                            continue;
                        }
                    };
                    debug!("Got request for service {topic} with key {:?}", query);

                    // Evaluate the server function inside a spawn_blocking to uphold trait expectations from roslibrust_common
                    let server_copy = server.clone();
                    let response = tokio::task::spawn_blocking(move || server_copy(req)).await;

                    let valid_response = match response {
                        Ok(Ok(response)) => response,
                        Ok(Err(e)) => {
                            error!("Failed to handle request in service {topic}: {e:?}");
                            continue;
                        }
                        Err(e) => {
                            error!("Failed to join task in service {topic}: {e:?}");
                            continue;
                        }
                    };
                    let send_result = service.send_response_async(&valid_response, &query).await;
                    match send_result {
                        Ok(()) => {}
                        Err(e) => {
                            error!("Failed to send response to service {topic}: {e:?}");
                        }
                    };
                }
            };

            tokio::select! {
                _ = ct_copy.cancelled() => {
                    // Shutdown
                }
                _ = body_future => {
                    error!("Service task for {topic} exited unexpectedly");
                }
            }
        });

        Ok(ZenohServiceServer { cancellation_token })
    }
}

#[cfg(test)]
mod tests {

    #[cfg(feature = "ros2_zenoh_test")]
    mod integration_tests {
        use crate::ZenohClient;
        use ros_z::context::ZContext;
        use roslibrust_common::traits::*;

        fn make_test_context() -> ZContext {
            use ros_z::context::ZContextBuilder;
            use ros_z::Builder;

            ZContextBuilder::default()
                .with_domain_id(0)
                .with_connect_endpoints(["tcp/[::]:7447"])
                .build()
                .unwrap()
        }

        #[tokio::test(flavor = "multi_thread")]
        async fn test_subscribe_basic() {
            let ctx = make_test_context();
            let client = ZenohClient::new(&ctx, "test_subscribe_basic_node")
                .await
                .unwrap();
            let mut subscriber = client
                .subscribe::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            #[allow(clippy::zombie_processes)]
            let mut pub_cmd = std::process::Command::new("ros2")
                .arg("topic")
                .arg("pub")
                // Publish 10 times
                .arg("-t")
                .arg("10")
                .arg("/chatter")
                .arg("std_msgs/msg/String")
                .arg("data: Hello World")
                .spawn()
                .unwrap();

            tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
                let msg = subscriber.next().await.unwrap();
                assert_eq!(msg.data, "Hello World");
            })
            .await
            .unwrap();

            pub_cmd.kill().unwrap();
        }

        #[tokio::test(flavor = "multi_thread")]
        async fn test_pubsub_basic() {
            let ctx = make_test_context();
            let client = ZenohClient::new(&ctx, "test_publish_basic_node")
                .await
                .unwrap();

            let publisher = client
                .advertise::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let mut subscriber = client
                .subscribe::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let msg = roslibrust_test::ros2::std_msgs::String {
                data: "Hello World".to_string(),
            };

            publisher.publish(&msg).await.unwrap();

            tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
                let msg = subscriber.next().await.unwrap();
                assert_eq!(msg.data, "Hello World");
            })
            .await
            .expect("Failed to receive message within 2 seconds");
        }

        // Test is currently failing... Want to merge this code and then file issues to gradually fix
        #[ignore]
        #[tokio::test(flavor = "multi_thread")]
        async fn test_service_server_callable() {
            let ctx = make_test_context();
            let client = ZenohClient::new(&ctx, "test_service_server_callable_node")
                .await
                .unwrap();

            let state = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));

            let state_copy = state.clone();
            let server_fn = move |request: roslibrust_test::ros2::std_srvs::SetBoolRequest| {
                state_copy.store(request.data, std::sync::atomic::Ordering::SeqCst);
                Ok(roslibrust_test::ros2::std_srvs::SetBoolResponse {
                    message: "You set my bool!".to_string(),
                    success: request.data,
                })
            };

            let _service = client
                .advertise_service::<roslibrust_test::ros2::std_srvs::SetBool, _>(
                    "/test_service_server_callable_node/set_bool",
                    server_fn,
                )
                .await
                .unwrap();

            #[allow(clippy::zombie_processes)]
            let mut srv_call_cmd = std::process::Command::new("ros2")
                .arg("service")
                .arg("call")
                .arg("/test_service_server_callable_node/set_bool")
                .arg("std_srvs/srv/SetBool")
                .arg("data: true")
                .spawn()
                .unwrap();

            tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
                while !state.load(std::sync::atomic::Ordering::SeqCst) {
                    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                }
            })
            .await
            .expect("Bool should be set true within 2 seconds");

            // If we reach here, state was changed to true by the service call!

            // Protection to make sure we don't leave a ros2 service call running
            srv_call_cmd.kill().unwrap()
        }

        #[tokio::test(flavor = "multi_thread")]
        async fn test_service_zenoh_to_zenoh() {
            let ctx = make_test_context();
            let node = ZenohClient::new(&ctx, "test_service_server_zenoh")
                .await
                .unwrap();

            let state = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
            let state_copy = state.clone();

            let server_fn = move |request: roslibrust_test::ros2::std_srvs::SetBoolRequest| {
                state_copy.store(request.data, std::sync::atomic::Ordering::SeqCst);
                Ok(roslibrust_test::ros2::std_srvs::SetBoolResponse {
                    message: "You set my bool!".to_string(),
                    success: request.data,
                })
            };

            let _service = node
                .advertise_service::<roslibrust_test::ros2::std_srvs::SetBool, _>(
                    "/test_service_zenoh_to_zenoh/set_bool",
                    server_fn,
                )
                .await
                .unwrap();

            // Give server time to start
            tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;

            // Create service client and call the service
            let response = node
                .call_service::<roslibrust_test::ros2::std_srvs::SetBool>(
                    "/test_service_zenoh_to_zenoh/set_bool",
                    roslibrust_test::ros2::std_srvs::SetBoolRequest { data: true },
                )
                .await
                .expect("Service call should succeed");

            // Verify the response
            assert!(response.success);
            assert_eq!(response.message, "You set my bool!");

            // Verify the server state was updated
            assert!(state.load(std::sync::atomic::Ordering::SeqCst));
        }
    }
}
