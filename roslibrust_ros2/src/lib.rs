use roslibrust_common::*;
use std::{any::Any, result::Result as StdResult};

use ros_z::{
    msg::ZService,
    pubsub::{ZPub, ZSub},
    Builder,
};

/// A "newtype" wrapper around ZNode so we can implement roslibrust's traits for it.
pub struct ZenohClient {
    // TODO: We'll probably end up wrapping node in an Arc<> so we can make this clone for users
    node: ros_z::node::ZNode,
}

// A "newtype" wrapper around ZPub so we can implement roslibrust's traits for it.
/// The publisher type returned by [TopicProvider::advertise] on [ZenohClient].
/// This type is self de-registering, and dropping the publisher will automatically un-advertise the topic.
/// This type is generic on the message type that will be published.
pub struct ZenohPublisher<T: RosMessageType> {
    publisher: ZPub<T>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Publish<T> for ZenohPublisher<T> {
    async fn publish(&self, data: &T) -> Result<()> {
        self.publisher
            .async_publish(data)
            .await
            // TODO: should work on error type here with ros_z team
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))
    }
}

/// The subscriber type returned by [TopicProvider::subscribe] on [ZenohClient].
/// This type is self de-registering, and dropping the subscriber will automatically unsubscribe from the topic.
/// This type is generic on the message type that will be received.
/// It is typically used with types generated by roslibrust's codegen.
pub struct ZenohSubscriber<T: RosMessageType> {
    // Very confused what to do with 2nd generic on ZSub...?
    subscriber: ZSub<T, T>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Subscribe<T> for ZenohSubscriber<T> {
    async fn next(&mut self) -> Result<T> {
        let next = self.subscriber.async_recv().await;
        let msg = next.map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;
        Ok(msg)
    }
}

impl ZenohClient {
    // TODO don't love error type here... could work with ros_z to get better errors
    /// Creates a new node with the specified name and return a handle to it.
    pub async fn new(
        name: impl AsRef<str>,
    ) -> StdResult<Self, Box<dyn std::error::Error + Send + Sync + 'static>> {
        // TODO FIX EXTREME JANK
        let mut config = zenoh::config::Config::default();
        config
            .insert_json5("connect/endpoints", "[ \"tcp/[::]:7447\" ]")
            .unwrap();
        std::fs::write("/tmp/ros_z_config.json5", config.to_string()).unwrap();
        std::env::set_var("ROSZ_CONFIG_FILE", "/tmp/ros_z_config.json5");

        let ctx = ros_z::context::ZContextBuilder::default()
            .with_domain_id(0)
            .build()?;
        let node = ctx.create_node(name.as_ref()).build()?;
        Ok(Self { node })
    }
}

impl roslibrust_common::TopicProvider for ZenohClient {
    type Publisher<T: RosMessageType> = ZenohPublisher<T>;
    type Subscriber<T: RosMessageType> = ZenohSubscriber<T>;

    async fn advertise<T: RosMessageType>(&self, topic: &str) -> Result<Self::Publisher<T>> {
        let publisher = self
            .node
            .create_pub::<T>(topic)
            .with_type_info(ros_z::entity::TypeInfo::new(
                T::ROS2_TYPE_NAME,
                ros_z::entity::TypeHash::from_rihs_string(T::ROS2_HASH)
                    .expect("Invalid hash in generated ROS2 hash"),
            ))
            .build()
            // TODO better errors
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;
        Ok(ZenohPublisher {
            publisher,
            _marker: std::marker::PhantomData,
        })
    }

    async fn subscribe<T: RosMessageType>(&self, topic: &str) -> Result<Self::Subscriber<T>> {
        let sub: ros_z::pubsub::ZSub<T, T> = self
            .node
            .create_sub::<T>(topic)
            .with_type_info(ros_z::entity::TypeInfo::new(
                T::ROS2_TYPE_NAME,
                ros_z::entity::TypeHash::from_rihs_string(T::ROS2_HASH)
                    .expect("Invalid hash in generated ROS2 hash"),
            ))
            .build()
            // TODO better errors
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        Ok(ZenohSubscriber {
            subscriber: sub,
            _marker: std::marker::PhantomData,
        })
    }
}

// TODO MAJOR: problem here ZService trait can't be implemented for our example messages due to orphan rule...
// Have to do some gross work around to get roslibrust::RosServiceType and ros_z::ZService to play nicely together
// struct ZenohServiceServer {}

// impl roslibrust_common::ServiceProvider for ZenohClient {
//     type ServiceClient<T: RosServiceType> = ();
//     type ServiceServer = ZenohServiceServer;

//     async fn call_service<T: RosServiceType>(
//         &self,
//         topic: &str,
//         request: T::Request,
//     ) -> Result<T::Response> {
//         todo!()
//     }

//     async fn service_client<T: RosServiceType + 'static>(
//         &self,
//         topic: &str,
//     ) -> Result<Self::ServiceClient<T>> {
//         todo!()
//     }

//     async fn advertise_service<T: RosServiceType + 'static, F>(
//         &self,
//         topic: &str,
//         server: F,
//     ) -> Result<Self::ServiceServer>
//     where
//         F: ServiceFn<T>,
//     {
//         // TODO MAJOR: doing some really dome stuff here... to work around orphan rule and RosServiceType != ZService
//         struct Fake<T>(T);
//         impl<T: RosServiceType> ZService for Fake<T> {
//             type Request = T::Request;
//             type Response = T::Response;
//         }

//         let service = self
//             .node
//             .create_service::<Fake<T>>(topic)
//             .build()
//             .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

//         let rx = service.rx;

//         // This gets really gross need to open some issues on ros-z
//         // there is no "take_request_async()" we can call so to async rx we'd have to deserialize ourselves
//         tokio::spawn(async move {
//             loop {
//                 let req = rx.recv_async().await;
//                 if let Err(_) = req {
//                     // TODO error handling here...
//                     continue;
//                 }
//                 let req = req.unwrap();

//             }
//         });

//         Ok(ZenohServiceServer {})
//     }
// }

#[cfg(test)]
mod tests {

    #[cfg(feature = "ros2_zenoh_test")]
    mod integration_tests {
        use crate::ZenohClient;
        use roslibrust_common::traits::*;

        #[tokio::test(flavor = "multi_thread")]
        async fn test_subscribe_basic() {
            let client = ZenohClient::new("test_subscribe_basic_node").await.unwrap();
            let mut subscriber = client
                .subscribe::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let mut pub_cmd = std::process::Command::new("ros2")
                .arg("topic")
                .arg("pub")
                // Publish 10 times
                .arg("-t")
                .arg("10")
                // Don't wait for subscriber to connect
                // TODO BUG HERE! We need to sort out liveliness stuff so this works with out -w 0
                .arg("-w")
                .arg("0")
                .arg("/chatter")
                .arg("std_msgs/msg/String")
                .arg("data: Hello World")
                .spawn()
                .unwrap();

            tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
                let msg = subscriber.next().await.unwrap();
                assert_eq!(msg.data, "Hello World");
            })
            .await
            .unwrap();

            pub_cmd.kill().unwrap();
        }

        #[tokio::test(flavor = "multi_thread")]
        async fn test_pubsub_basic() {
            use roslibrust_common::traits::*;
            let client = ZenohClient::new("test_publish_basic_node").await.unwrap();

            let publisher = client
                .advertise::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let client2 = ZenohClient::new("test_publish_basic_node2").await.unwrap();

            let mut subscriber = client2
                .subscribe::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let msg = roslibrust_test::ros2::std_msgs::String {
                data: "Hello World".to_string(),
            };

            publisher.publish(&msg).await.unwrap();
            let received_msg = subscriber.next().await.unwrap();

            assert_eq!(msg, received_msg);
        }
    }
}
