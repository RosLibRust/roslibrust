use log::error;
use roslibrust_common::*;
use std::{any::Any, result::Result as StdResult};

use ros_z::{
    msg::ZService,
    pubsub::{ZPub, ZSub},
    Builder,
};

/// A "newtype" wrapper around ZNode so we can implement roslibrust's traits for it.
pub struct ZenohClient {
    // TODO: We'll probably end up wrapping node in an Arc<> so we can make this clone for users
    node: ros_z::node::ZNode,
}

// A "newtype" wrapper around ZPub so we can implement roslibrust's traits for it.
/// The publisher type returned by [TopicProvider::advertise] on [ZenohClient].
/// This type is self de-registering, and dropping the publisher will automatically un-advertise the topic.
/// This type is generic on the message type that will be published.
pub struct ZenohPublisher<T: RosMessageType> {
    publisher: ZPub<T>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Publish<T> for ZenohPublisher<T> {
    async fn publish(&self, data: &T) -> Result<()> {
        self.publisher
            .async_publish(data)
            .await
            // TODO: should work on error type here with ros_z team
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))
    }
}

/// The subscriber type returned by [TopicProvider::subscribe] on [ZenohClient].
/// This type is self de-registering, and dropping the subscriber will automatically unsubscribe from the topic.
/// This type is generic on the message type that will be received.
/// It is typically used with types generated by roslibrust's codegen.
pub struct ZenohSubscriber<T: RosMessageType> {
    // Very confused what to do with 2nd generic on ZSub...?
    subscriber: ZSub<T, T>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Subscribe<T> for ZenohSubscriber<T> {
    async fn next(&mut self) -> Result<T> {
        let next = self.subscriber.async_recv().await;
        let msg = next.map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;
        Ok(msg)
    }
}

impl ZenohClient {
    // TODO don't love error type here... could work with ros_z to get better errors
    /// Creates a new node with the specified name and return a handle to it.
    pub async fn new(
        name: impl AsRef<str>,
    ) -> StdResult<Self, Box<dyn std::error::Error + Send + Sync + 'static>> {
        // TODO FIX EXTREME JANK
        let mut config = zenoh::config::Config::default();
        config
            .insert_json5("connect/endpoints", "[ \"tcp/[::]:7447\" ]")
            .unwrap();
        std::fs::write("/tmp/ros_z_config.json5", config.to_string()).unwrap();
        std::env::set_var("ROSZ_CONFIG_FILE", "/tmp/ros_z_config.json5");

        let ctx = ros_z::context::ZContextBuilder::default()
            .with_domain_id(0)
            .build()?;
        let node = ctx.create_node(name.as_ref()).build()?;
        Ok(Self { node })
    }
}

impl roslibrust_common::TopicProvider for ZenohClient {
    type Publisher<T: RosMessageType> = ZenohPublisher<T>;
    type Subscriber<T: RosMessageType> = ZenohSubscriber<T>;

    async fn advertise<T: RosMessageType>(&self, topic: &str) -> Result<Self::Publisher<T>> {
        let publisher = self
            .node
            .create_pub::<T>(topic)
            .with_type_info(ros_z::entity::TypeInfo::new(
                T::ROS2_TYPE_NAME,
                ros_z::entity::TypeHash::from_rihs_string(T::ROS2_HASH)
                    .expect("Invalid hash in generated ROS2 hash"),
            ))
            .build()
            // TODO better errors
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;
        Ok(ZenohPublisher {
            publisher,
            _marker: std::marker::PhantomData,
        })
    }

    async fn subscribe<T: RosMessageType>(&self, topic: &str) -> Result<Self::Subscriber<T>> {
        let sub: ros_z::pubsub::ZSub<T, T> = self
            .node
            .create_sub::<T>(topic)
            .with_type_info(ros_z::entity::TypeInfo::new(
                T::ROS2_TYPE_NAME,
                ros_z::entity::TypeHash::from_rihs_string(T::ROS2_HASH)
                    .expect("Invalid hash in generated ROS2 hash"),
            ))
            .build()
            // TODO better errors
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        Ok(ZenohSubscriber {
            subscriber: sub,
            _marker: std::marker::PhantomData,
        })
    }
}

// TODO MAJOR: problem here ZService trait can't be implemented for our example messages due to orphan rule...
// Have to do some gross work around to get roslibrust::RosServiceType and ros_z::ZService to play nicely together
pub struct ZenohServiceServer {
    // Used to shutdown server task when dropped
    cancellation_token: tokio_util::sync::CancellationToken,
}

impl Drop for ZenohServiceServer {
    fn drop(&mut self) {
        self.cancellation_token.cancel();
    }
}

pub struct ZenohServiceClient<T: RosServiceType> {
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosServiceType> roslibrust_common::Service<T> for ZenohServiceClient<T> {
    async fn call(&self, request: &T::Request) -> Result<T::Response> {
        todo!()
    }
}

impl roslibrust_common::ServiceProvider for ZenohClient {
    type ServiceClient<T: RosServiceType> = ZenohServiceClient<T>;
    type ServiceServer = ZenohServiceServer;

    async fn call_service<T: RosServiceType>(
        &self,
        topic: &str,
        request: T::Request,
    ) -> Result<T::Response> {
        todo!()
    }

    async fn service_client<T: RosServiceType + 'static>(
        &self,
        topic: &str,
    ) -> Result<Self::ServiceClient<T>> {
        todo!()
    }

    async fn advertise_service<T: RosServiceType + 'static, F>(
        &self,
        topic: &str,
        server: F,
    ) -> Result<Self::ServiceServer>
    where
        F: ServiceFn<T>,
    {
        // TODO: doing some really dome stuff here... to work around orphan rule and RosServiceType != ZService
        struct Fake<T>(T);
        impl<T: RosServiceType> ZService for Fake<T> {
            type Request = T::Request;
            type Response = T::Response;
        }

        let mut service = self
            .node
            .create_service::<Fake<T>>(topic)
            .build()
            .map_err(|e| Error::Unexpected(anyhow::anyhow!(e)))?;

        let cancellation_token = tokio_util::sync::CancellationToken::new();

        // Build a clone wrapper for the users's function
        let server = std::sync::Arc::new(server);
        let topic = topic.to_string();
        let ct_copy = cancellation_token.clone();
        tokio::spawn(async move {
            let body_future = async {
                loop {
                    let req = service.take_request_async().await;
                    let (query, req) = match req {
                        Ok(req) => req,
                        Err(e) => {
                            error!("Failed to take request in service {topic}: {e:?}");
                            continue;
                        }
                    };

                    // Evaluate the server function inside a spawn_blocking to uphold trait expectations from roslibrust_common
                    let server_copy = server.clone();
                    let response = tokio::task::spawn_blocking(move || server_copy(req)).await;

                    let valid_response = match response {
                        Ok(Ok(response)) => response,
                        Ok(Err(e)) => {
                            error!("Failed to handle request in service {topic}: {e:?}");
                            continue;
                        }
                        Err(e) => {
                            error!("Failed to join task in service {topic}: {e:?}");
                            continue;
                        }
                    };
                    // TODO Need to swap send_response with send_response_async when fix for that merges
                    // https://github.com/ZettaScaleLabs/ros-z/pull/5
                    let send_result = service.send_response(&valid_response, &query);
                    match send_result {
                        Ok(()) => {}
                        Err(e) => {
                            error!("Failed to send response to service {topic}: {e:?}");
                        }
                    };
                }
            };

            tokio::select! {
                _ = ct_copy.cancelled() => {
                    // Shutdown
                }
                _ = body_future => {
                    error!("Service task for {topic} exited unexpectedly");
                }
            }
        });

        Ok(ZenohServiceServer { cancellation_token })
    }
}

#[cfg(test)]
mod tests {

    #[cfg(feature = "ros2_zenoh_test")]
    mod integration_tests {
        use crate::ZenohClient;
        use roslibrust_common::traits::*;

        #[tokio::test(flavor = "multi_thread")]
        async fn test_subscribe_basic() {
            let client = ZenohClient::new("test_subscribe_basic_node").await.unwrap();
            let mut subscriber = client
                .subscribe::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let mut pub_cmd = std::process::Command::new("ros2")
                .arg("topic")
                .arg("pub")
                // Publish 10 times
                .arg("-t")
                .arg("10")
                // Don't wait for subscriber to connect
                // TODO BUG HERE! We need to sort out liveliness stuff so this works with out -w 0
                .arg("-w")
                .arg("0")
                .arg("/chatter")
                .arg("std_msgs/msg/String")
                .arg("data: Hello World")
                .spawn()
                .unwrap();

            tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
                let msg = subscriber.next().await.unwrap();
                assert_eq!(msg.data, "Hello World");
            })
            .await
            .unwrap();

            pub_cmd.kill().unwrap();
        }

        #[tokio::test(flavor = "multi_thread")]
        async fn test_pubsub_basic() {
            let client = ZenohClient::new("test_publish_basic_node").await.unwrap();

            let publisher = client
                .advertise::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let client2 = ZenohClient::new("test_publish_basic_node2").await.unwrap();

            let mut subscriber = client2
                .subscribe::<roslibrust_test::ros2::std_msgs::String>("/chatter")
                .await
                .unwrap();

            let msg = roslibrust_test::ros2::std_msgs::String {
                data: "Hello World".to_string(),
            };

            publisher.publish(&msg).await.unwrap();

            tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
                let msg = subscriber.next().await.unwrap();
                assert_eq!(msg.data, "Hello World");
            })
            .await
            .expect("Failed to receive message within 2 seconds");
        }

        #[tokio::test(flavor = "multi_thread")]
        async fn test_service_server_callable() {
            let client = ZenohClient::new("test_service_server_callable_node")
                .await
                .unwrap();

            let state = std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));

            let state_copy = state.clone();
            let server_fn = move |request: roslibrust_test::ros2::std_srvs::SetBoolRequest| {
                state_copy.store(request.data, std::sync::atomic::Ordering::SeqCst);
                Ok(roslibrust_test::ros2::std_srvs::SetBoolResponse {
                    message: "You set my bool!".to_string(),
                    success: request.data,
                })
            };

            client
                .advertise_service::<roslibrust_test::ros2::std_srvs::SetBool, _>(
                    "/test_service_server_callable_node/set_bool",
                    server_fn,
                )
                .await
                .unwrap();

            tokio::time::sleep(tokio::time::Duration::from_secs(100000)).await;

            let mut srv_call_cmd = std::process::Command::new("ros2")
                .arg("service")
                .arg("call")
                .arg("/test_service_server_callable_node/set_bool")
                .arg("std_srvs/srv/SetBool")
                .arg("data: true")
                .spawn()
                .unwrap();

            tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
                while !state.load(std::sync::atomic::Ordering::SeqCst) {
                    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                }
            })
            .await
            .expect("Bool should be set true within 2 seconds");

            // If we reach here, state was changed to true by the service call!

            // Protection to make sure we don't leave a ros2 service call running
            srv_call_cmd.kill().unwrap()
        }
    }
}
