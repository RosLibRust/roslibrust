use roslibrust_common::*;

pub struct ZenohClient {
    session: zenoh::Session,
}

pub struct ZenohPublisher<T: RosMessageType> {
    publisher: zenoh::pubsub::Publisher<'static>,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Publish<T> for ZenohPublisher<T> {
    async fn publish(&self, data: &T) -> Result<()> {
        let bytes = cdr::serialize::<_, _, cdr::CdrLe>(data, cdr::Infinite).map_err(|e| {
            Error::SerializationError(format!("Failed to serialize message: {e:?}"))
        })?;
        match self.publisher.put(&bytes).await {
            Ok(()) => Ok(()),
            Err(e) => Err(Error::Unexpected(anyhow::anyhow!(
                "Failed to publish message to zenoh: {e:?}"
            ))),
        }
    }
}

// Using type alias here, I have no idea why zenoh has this type so deep
type ZenohSubInner =
    zenoh::pubsub::Subscriber<zenoh::handlers::FifoChannelHandler<zenoh::sample::Sample>>;

/// The subscriber type returned by [TopicProvider::subscribe] on [ZenohClient].
/// This type is self de-registering, and dropping the subscriber will automatically unsubscribe from the topic.
/// This type is generic on the message type that will be received.
/// It is typically used with types generated by roslibrust's codegen.
pub struct ZenohSubscriber<T: RosMessageType> {
    subscriber: ZenohSubInner,
    _marker: std::marker::PhantomData<T>,
}

impl<T: RosMessageType> Subscribe<T> for ZenohSubscriber<T> {
    async fn next(&mut self) -> Result<T> {
        let next = self.subscriber.recv_async().await;

        let sample = match next {
            Ok(sample) => sample,
            Err(e) => {
                // TODO errors still suck with this API
                return Err(Error::Unexpected(anyhow::anyhow!(
                    "Failed to receive next sample: {e:?}"
                )));
            }
        };

        let bytes = sample.payload().to_bytes();
        let msg = cdr::deserialize::<T>(&bytes).map_err(|e| {
            Error::SerializationError(format!("Failed to deserialize sample: {e:?}"))
        })?;
        Ok(msg)
    }
}

impl ZenohClient {
    /// Creates a zenoh client configured to connect to rmw_zenohd at the default location
    pub async fn new_default() -> Self {
        // Configure zenoh to explicitly connect to rmw_zenohd
        // See: https://github.com/ros2/rmw_zenoh/blob/rolling/rmw_zenoh_cpp/config/DEFAULT_RMW_ZENOH_ROUTER_CONFIG.json5 for router setup
        let mut config = zenoh::Config::default();
        // Default location where rmw_zenohd listens for connections
        config
            .insert_json5("connect/endpoints", "[ \"tcp/[::]:7447\" ]")
            .unwrap();
        let session = zenoh::open(config).await.unwrap();
        Self::new_internal(session).await
    }

    /// Creates a zenoh client from the explicit configuration provided
    pub async fn new(config: zenoh::Config) -> Self {
        let session = zenoh::open(config).await.unwrap();
        Self::new_internal(session).await
    }

    async fn new_internal(session: zenoh::Session) -> Self {
        // TODO need to declare liveliness tokens here...

        Self { session }
    }
}

impl roslibrust_common::TopicProvider for ZenohClient {
    type Publisher<T: RosMessageType> = ZenohPublisher<T>;
    type Subscriber<T: RosMessageType> = ZenohSubscriber<T>;

    async fn advertise<T: RosMessageType>(&self, topic: &str) -> Result<Self::Publisher<T>> {
        // TODO seems like we need to declare some liveliness tokens here to get things to work better

        let mangled_topic = mangle_topic(topic, T::ROS2_TYPE_NAME, T::ROS2_HASH);
        let publisher = match self.session.declare_publisher(mangled_topic).await {
            Ok(publisher) => publisher,
            Err(e) => {
                // TODO errors still suck with this API...
                return Err(Error::Unexpected(anyhow::anyhow!(
                    "Failed to declare publisher: {e:?}"
                )));
            }
        };
        Ok(ZenohPublisher {
            publisher,
            _marker: std::marker::PhantomData,
        })
    }

    async fn subscribe<T: RosMessageType>(&self, topic: &str) -> Result<Self::Subscriber<T>> {
        // TODO seems like we need to declare some liveliness tokens here to get things to work better

        let mangled_topic = mangle_topic(topic, T::ROS2_TYPE_NAME, T::ROS2_HASH);
        let sub = match self.session.declare_subscriber(mangled_topic).await {
            Ok(sub) => sub,
            Err(e) => {
                // TODO errors still suck with this API...
                return Err(Error::Unexpected(anyhow::anyhow!(
                    "Failed to declare subscriber: {e:?}"
                )));
            }
        };
        Ok(ZenohSubscriber {
            subscriber: sub,
            _marker: std::marker::PhantomData,
        })
    }
}

/// Converts a ros2 topic name and type into a ros2 zenoh topic name
fn mangle_topic(topic: &str, fully_qualified_type_name: &str, ros2_hash: &str) -> String {
    // Format for topics and services: <domain_id>/<fully_qualified_name>/<type_name>/<type_hash>
    // Example from ros2 topic echo: 0/chatter/std_msgs::msg::dds_::String_/RIHS01_df668c740482bbd48fb39d76a70dfd4bd59db1288021743503259e948f6b1a18
    // TODO: For now hardcoding domain_id to 0
    // TODO: topic mangling stuff with leading and trailing slashes and ~ and such
    format!("0{}/{}/{}", topic, fully_qualified_type_name, ros2_hash)
}

#[cfg(test)]
mod tests {
    // Basic test showing serialization and deserialization of a simple string message with Serde and cdr
    #[test]
    fn test_deserialize_hello_world() {
        // Test data was taken from a manual zenoh subscription against `ros2 topic pub /chatter std_msgs/msg/String 'data: Hello World'`
        let zenoh_bytes: [u8; 20] = [
            0x00, 0x01, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x20,
            0x57, 0x6f, 0x72, 0x6c, 0x64, 0x00,
        ];

        // Example struct we expect to convert to/from std_msgs::String in ros
        #[derive(serde::Deserialize, serde::Serialize)]
        struct StdMsgString {
            data: String,
        }

        // Serialize
        let serialized = cdr::serialize::<_, _, cdr::CdrLe>(
            &StdMsgString {
                data: "Hello World".to_string(),
            },
            cdr::Infinite,
        )
        .unwrap();
        assert_eq!(serialized, zenoh_bytes);

        // Deserialize
        let deserialized = cdr::deserialize::<StdMsgString>(&zenoh_bytes).unwrap();
        assert_eq!(deserialized.data, "Hello World");
    }

    #[cfg(feature = "ros2_zenoh_test")]
    #[tokio::test(flavor = "multi_thread")]
    async fn test_subscribe_basic() {
        use roslibrust_common::traits::*;
        let client = super::ZenohClient::new_default().await;
        let mut subscriber = client
            .subscribe::<roslibrust_test::ros2::std_msgs::String>("/chatter")
            .await
            .unwrap();

        let mut pub_cmd = std::process::Command::new("ros2")
            .arg("topic")
            .arg("pub")
            // Publish 10 times
            .arg("-t")
            .arg("10")
            // Don't wait for subscriber to connect
            // TODO BUG HERE! We need to sort out liveliness stuff so this works with out -w 0
            .arg("-w")
            .arg("0")
            .arg("/chatter")
            .arg("std_msgs/msg/String")
            .arg("data: Hello World")
            .spawn()
            .unwrap();

        tokio::time::timeout(tokio::time::Duration::from_secs(2), async {
            let msg = subscriber.next().await.unwrap();
            assert_eq!(msg.data, "Hello World");
        })
        .await
        .unwrap();

        pub_cmd.kill().unwrap();
    }
}
